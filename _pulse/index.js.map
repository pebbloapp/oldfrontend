{"version":3,"sources":["webpack://pulse-framework/./lib/api/api.ts","webpack://pulse-framework/./lib/collection/collection.ts","webpack://pulse-framework/./lib/collection/data.ts","webpack://pulse-framework/./lib/collection/group.ts","webpack://pulse-framework/./lib/collection/selector.ts","webpack://pulse-framework/./lib/computed.ts","webpack://pulse-framework/./lib/controller.ts","webpack://pulse-framework/./lib/dep.ts","webpack://pulse-framework/./lib/event.ts","webpack://pulse-framework/./lib/helpers/deepmerge.ts","webpack://pulse-framework/./lib/helpers/extractAll.ts","webpack://pulse-framework/./lib/helpers/isWatchableObj.ts","webpack://pulse-framework/./lib/index.ts","webpack://pulse-framework/./lib/integrations/react.integration.ts","webpack://pulse-framework/./lib/integrations/use.ts","webpack://pulse-framework/./lib/integrations/vue.integration.ts","webpack://pulse-framework/./lib/internal.ts","webpack://pulse-framework/./lib/pulse.ts","webpack://pulse-framework/./lib/runtime.ts","webpack://pulse-framework/./lib/state.ts","webpack://pulse-framework/./lib/status.ts","webpack://pulse-framework/./lib/storage.ts","webpack://pulse-framework/./lib/sub.ts","webpack://pulse-framework/./lib/utils.ts","webpack://pulse-framework/webpack/bootstrap","webpack://pulse-framework/webpack/startup","webpack://pulse-framework/webpack/runtime/hasOwnProperty shorthand","webpack://pulse-framework/webpack/runtime/jsonp chunk loading"],"names":["ensureProperHeaders","headers","obj","Object","keys","forEach","t","toLowerCase","API","config","options","_this","assign","create","getPrototypeOf","this","endpoint","send","payload","method","fullUrl","response","originalType","_parts","getParts","body","JSON","stringify","path","startsWith","baseURL","requestIntercept","timedout","timeout","Promise","resolve","setTimeout","request","reject","fetch","then","data","clearTimeout","catch","race","res","status","raw","type","get","includes","json","text","responseIntercept","Collection","instance","size","_groups","Set","_selectors","defineConfig","primaryKey","groups","initSubInstances","selectors","defaultGroup","createGroup","subInstanceType","subInstanceObj","subInstanceName","value","name","key","initialIndex","group","Group","add","initialSelection","selector","Selector","groupName","selectorName","initialSelected","patch","hasOwnProperty","deep","set","Data","items","_items","normalizeArray","item","index","saveData","forEachItem","nextState","runtime","ingest","id","State","undefined","findById","computedFunc","updateKey","changes","updateDataKey","primary","currentData","copy","final","deepmerge","shallowmerge","rebuildGroupsThatInclude","func","primaryKeys","groupNames","fromGroups","removeFromGroups","everywhere","deleteData","getGroup","remove","filter","oldKey","newKey","dataCopy","_value","splice","indexOf","has","reset","collection","super","context","Pulse","_masterOutput","missingPrimaryKeys","Array","sideEffects","build","trackState","foundState","isArray","map","getPublicValue","push","length","useIndex","overwrite","atIndex","exists","i","Computed","findData","_masterSelected","val","recompute","persistState","storage","handleStatePersist","deps","computedDefault","state","dep","depend","noCore","console","error","computed","getFoundState","computeValue","Controller","sectionName","Event","event","bindObj","propertyName","Dep","initialDeps","subs","callbacks","disableAfterUses","uses","queue","callback","cleanupFunc","unsub","maxSubs","disable","enabled","throttle","handleThrottle","emitter","delete","throttling","currentTimeout","looper","shift","isSpecial","stringValue","prototype","toString","call","isReactElement","$$typeof","REACT_ELEMENT_TYPE","Symbol","for","defaultIsMergeableObject","isNonNullObject","cloneUnlessOtherwiseSpecified","clone","isMergeableObject","emptyTarget","defaultArrayMerge","target","source","concat","element","getKeys","getEnumerableOwnPropertySymbols","getOwnPropertySymbols","symbol","propertyIsEnumerable","propertyIsOnObject","object","property","_","mergeObject","destination","propertyIsUnsafe","getMergeFunction","customMerge","arrayMerge","sourceIsArray","extractAll","findClass","inObj","found","next","look","_next","o","typelessObject","isWatchableObject","isHTMLElement","HTMLElement","e","nodeType","style","ownerDocument","PulseHOC","ReactComponent","pulseInstance","depsArray","depsObject","normalizeDeps","tempPulseInstance","getPulseInstance","warn","objectKeys","React","integration","frameworkConstructor","Component","props","componentContainer","updatedProps","subController","subscribeWithSubsArray","subscribeWithSubsObject","waitForMount","mount","unsubscribe","createElement","usePulse","set_","useState","useEffect","subscriptionContainer","useEvent","on","componentInstance","updatedData","setState","forceUpdate","ready","use","plugin","frameworkName","getFrameworkName","integrate","validateCustomFramework","customIntegration","valid","bind","int","ReturnType","log","depsArrayFinal","depsObjFinal","STRING","STATE","d","KEYED","pulseConstructor","install","Vue","globalThis","__pulse","_SSOT","mixin","dataKey","$set","StateGroup","StatusTracker","Runtime","Storage","SubController","ComponentContainer","CallbackContainer","cleanState","resetState","persist","defaultConfig","controllers","errorHandlers","core","framework","initFrameworkIntegration","onInstanceReady","globalBind","initial","eventsFunc","eventObj","eventName","setStorage","stateGroup","code","handler","nextPulse","p","persistedState","__pulse__","__pulse__app","currentJob","jobsQueue","jobsToRerender","tasksOnceComplete","newStateValue","perform","background","job","performJob","previousState","privateWrite","logJobs","updateSubscribers","watcher","watchers","subscriptionsToUpdate","passProps","localKey","propStates","propKeysChanged","updateMethod","component","formatChangedPropKeys","task","finalObject","changedKey","ret","initialState","isSet","newState","typeOfVal","isCorrectType","output","targetWithChange","setFunc","ms","setInterval","supportedConstructors","x","getPersistableValue","clear","initialData","message","StatusObject","copiedState","newStatus","messageText","storageReady","prefix","ls","getLocalStorage","isFunction","async","isAsync","getKey","parse","handle","storageVal","window","localStorage","getItem","components","subscriptionInstance","registerSubscription","default","integrationInstance","callbackContainer","dependents","subscribers","normalizeGroups","groupsAsArray","defaults","genId","Math","random","split","Date","now","constructor","normalizeMap","cleanse","clean","properties","validateNumber","mutable","amount","__webpack_module_cache__","__webpack_require__","moduleId","exports","module","__webpack_modules__","m","prop","installedChunks","deferredModules","checkDeferredModules","checkDeferredModulesImpl","result","deferredModule","fulfilled","j","depId","s","chunkLoadingGlobal","slice","webpackJsonpCallback","chunkId","chunkIds","moreModules","executeModules","resolves","parentChunkLoadingFunction","apply"],"mappings":"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","file":"index.js","sourcesContent":["import * as http from 'http';\r\n\r\ntype Body = { [key: string]: any };\r\n\r\nexport interface PulseResponse<DataType = any> {\r\n  data: DataType;\r\n  timedout?: boolean;\r\n  status: number;\r\n  raw?: Response;\r\n  type?: string;\r\n}\r\n\r\nexport interface APIConfig {\r\n  options: RequestInit;\r\n  baseURL?: string;\r\n  path?: string;\r\n  timeout?: number;\r\n  requestIntercept?: Function;\r\n  responseIntercept?: Function;\r\n}\r\n\r\nconst ensureProperHeaders = headers => {\r\n  let obj = {};\r\n  Object.keys(headers).forEach(t => {\r\n    obj[t.toLowerCase()] = headers[t];\r\n  });\r\n  return obj;\r\n};\r\n\r\nexport class API {\r\n  constructor(public config: APIConfig = { options: {} }) {\r\n    if (config.options && config.options.headers) {\r\n      config.options.headers = ensureProperHeaders(config.options.headers);\r\n    }\r\n\r\n    if (!config.options) config.options = {};\r\n  }\r\n\r\n  /**\r\n   * Override API config and request options. Returns a modified instance this API with overrides applied.\r\n   * @param config - O\r\n   */\r\n  public with(config: APIConfig): API {\r\n    let _this = Object.assign(Object.create(Object.getPrototypeOf(this)), this);\r\n\r\n    if (config.options && config.options.headers) {\r\n      config.options.headers = ensureProperHeaders({\r\n        ..._this.config.options.headers,\r\n        ...config.options.headers\r\n      });\r\n    }\r\n\r\n    _this.config = {\r\n      ..._this.config,\r\n      ...config\r\n    };\r\n    return _this;\r\n  }\r\n  public get(endpoint: string) {\r\n    return this.send('GET', endpoint);\r\n  }\r\n  public post(endpoint: string, payload?: any) {\r\n    return this.send('POST', endpoint, payload);\r\n  }\r\n  public put(endpoint: string, payload?: any) {\r\n    return this.send('PUT', endpoint, payload);\r\n  }\r\n  public patch(endpoint: string, payload?: any) {\r\n    return this.send('PATCH', endpoint, payload);\r\n  }\r\n  public delete(endpoint: string, payload?: any) {\r\n    return this.send('DELETE', endpoint, payload);\r\n  }\r\n\r\n  private async send(method: string, endpoint, payload?: any): Promise<PulseResponse> {\r\n    // initial definitions\r\n    let fullUrl: string,\r\n      data: any,\r\n      response: PulseResponse | unknown,\r\n      config: APIConfig = { ...this.config };\r\n\r\n    // inject method into request options\r\n    config.options.method = method;\r\n\r\n    if (!config.options.headers) config.options.headers = {};\r\n    let originalType = config.options.headers['content-type'] || config.options.headers['Content-Type'];\r\n\r\n    if (payload && payload._parts && payload.getParts) {\r\n      // inject body if not get method\r\n      config.options.body = payload;\r\n      config.options.headers['content-type'] = 'multipart/form-data';\r\n    } else if (typeof payload === 'object') {\r\n      // inject body if not get method\r\n      config.options.body = JSON.stringify(payload);\r\n      config.options.headers['content-type'] = 'application/json';\r\n    } else config.options.body = payload;\r\n\r\n    // construct endpoint\r\n    let path = this.config.path ? '/' + this.config.path : '';\r\n    if (endpoint.startsWith('http')) fullUrl = endpoint;\r\n    else fullUrl = `${this.config.baseURL ? this.config.baseURL : ''}${path}/${endpoint}`;\r\n\r\n    if (config.requestIntercept) config.requestIntercept({ ...config.options, endpoint: fullUrl });\r\n\r\n    let timedout = false;\r\n    if (this.config.timeout) {\r\n      let t: any;\r\n      const timeout = new Promise(resolve => {\r\n        t = setTimeout(() => {\r\n          timedout = true;\r\n          resolve();\r\n        }, this.config.timeout);\r\n      });\r\n      const request = new Promise((resolve, reject) => {\r\n        fetch(fullUrl, this.config.options)\r\n          .then(data => {\r\n            clearTimeout(t);\r\n            resolve(data);\r\n          })\r\n          .catch(reject);\r\n      });\r\n      response = await Promise.race([timeout, request]);\r\n    } else {\r\n      response = await fetch(fullUrl, this.config.options);\r\n    }\r\n\r\n    // Return the old content type header\r\n    if (originalType) config.options.headers['content-type'] = originalType;\r\n\r\n    // if we got here, PulseResponse is the actual response object\r\n    let res: PulseResponse = {\r\n      status: timedout ? 408 : (response as Response)?.status,\r\n      raw: response as Response,\r\n      data: {},\r\n      type: (response as Response)?.headers?.get('content-type') || 'text/plain',\r\n      timedout\r\n    };\r\n\r\n    // extract response data\r\n    if (res.type?.includes('application/json')) {\r\n      res.data = await res.raw.json();\r\n    } else if (typeof res?.raw?.text === 'function') {\r\n      res.data = await res.raw.text();\r\n    }\r\n\r\n    if (config.responseIntercept) config.responseIntercept(res);\r\n\r\n    return res;\r\n  }\r\n}\r\n\r\nexport default API;\r\n","import { Pulse, State, Group, PrimaryKey, GroupName, GroupAddOptions, Selector, Data } from '../internal';\r\nimport { defineConfig, shallowmerge } from '../utils';\r\nimport { deepmerge } from '../helpers/deepmerge';\r\nimport { normalizeArray } from '../utils';\r\n\r\n// Shorthand for an expandable object\r\ntype Expandable = { [key: string]: any };\r\n\r\ninterface RemoveOptions {\r\n  fromGroups: (groups: string | number | Array<string>) => any;\r\n  everywhere: () => any;\r\n}\r\nexport interface DefaultDataItem extends Expandable {}\r\n\r\n// Defaults for collection sub instance objects, used as generics\r\nexport type GroupObj = { [key: string]: Group<any> };\r\nexport type SelectorObj = { [key: string]: Selector<any> };\r\n\r\n// Interface for the collection config object\r\nexport interface CollectionConfig<G, S> {\r\n  groups?: G;\r\n  selectors?: S;\r\n  name?: string;\r\n  primaryKey?: string | number;\r\n  defaultGroup?: boolean;\r\n}\r\n\r\n// An optional type defining config as either an object, or an object that returns a function\r\nexport type Config<DataType = DefaultDataItem, G = GroupObj, S = SelectorObj> =\r\n  | CollectionConfig<G, S>\r\n  | ((collection: Collection<DataType>) => CollectionConfig<G, S>);\r\n\r\n// The collection class, should be created by the Pulse class for functioning types\r\nexport class Collection<DataType = DefaultDataItem, G = GroupObj, S = SelectorObj> {\r\n  public config: Required<CollectionConfig<G, S>>;\r\n  // the amount of data items stored inside this collection\r\n  public size: number = 0;\r\n\r\n  // collection data is stored here\r\n  public data: { [key: string]: Data<DataType> } = {};\r\n\r\n  public groups: this['config']['groups'];\r\n  public selectors: this['config']['selectors'];\r\n\r\n  private _groups: Set<Group<DataType>> = new Set();\r\n  private _selectors: Set<Selector<DataType>> = new Set();\r\n\r\n  public computedFunc: (data: DataType) => DataType;\r\n\r\n  // collection config can either be an object of type CollectionConfig or a function that returns CollectionConfig\r\n  constructor(public instance: () => Pulse, config: Config<DataType, G, S>) {\r\n    // if collection config is a function, execute and assign to config\r\n    if (typeof config === 'function') config = config(this) as CollectionConfig<G, S>;\r\n\r\n    // assign defaults to config object ensuring type safety\r\n    this.config = defineConfig<typeof config>(config, {\r\n      primaryKey: 'id'\r\n    }) as Required<typeof config>;\r\n\r\n    // create groups\r\n    if (this.config.groups) this.initSubInstances('groups');\r\n    if (this.config.selectors) this.initSubInstances('selectors');\r\n\r\n    if (this.config.defaultGroup || !this.config.groups) {\r\n      if (!this.groups) this.groups = {} as any;\r\n      this.createGroup('default');\r\n    }\r\n  }\r\n\r\n  private initSubInstances(subInstanceType: 'groups' | 'selectors') {\r\n    const subInstanceObj: any = {};\r\n    // You'll need the below code when you add support for arrays of group names ;)\r\n    // const subInstanceTypeGeneratorName = subInstanceType.charAt(0).toUpperCase() + subInstanceType.slice(1, -1);\r\n    // const keys: Array<string> = Array.isArray(this.config[subInstanceType])\r\n    //   ? (this.config[subInstanceType] as Array<string>)\r\n    //   : Object.keys(this.config[subInstanceType]);\r\n\r\n    const keys = Object.keys(this.config[subInstanceType]);\r\n\r\n    for (const subInstanceName of keys) {\r\n      let value = this.config[subInstanceType][subInstanceName];\r\n      // create the sub instance\r\n      subInstanceObj[subInstanceName] = value;\r\n      // assign sub instance to instance and inject key of the sub instance name\r\n      if (!subInstanceObj[subInstanceName].name) subInstanceObj[subInstanceName].key(subInstanceName);\r\n    }\r\n    this[subInstanceType] = subInstanceObj;\r\n  }\r\n\r\n  /**\r\n   * Create a group associated with this collection\r\n   * @param initialIndex - An optional array of primary keys to initialize this groups with.\r\n   */\r\n  public Group(initialIndex?: Array<PrimaryKey>): Group<DataType> {\r\n    const group = new Group<DataType>(() => this, initialIndex);\r\n    this._groups.add(group);\r\n    return group;\r\n  }\r\n  // create a selector instance under this collection\r\n  public Selector(initialSelection?: string | number): Selector<DataType> {\r\n    const selector = new Selector<DataType>(() => this, initialSelection);\r\n    this._selectors.add(selector);\r\n    return selector;\r\n  }\r\n\r\n  /**\r\n   * Create a group associated with this collection\r\n   * @param initialIndex - An optional array of primary keys to initialize this groups with.\r\n   */\r\n  public createGroup(groupName: GroupName, initialIndex?: Array<PrimaryKey>): Group<DataType> {\r\n    if (this.groups[groupName]) return this.groups[groupName];\r\n    const group = this.Group(initialIndex).key(groupName as string);\r\n    this.groups[groupName] = group;\r\n    return group;\r\n  }\r\n  // create a selector instance on this collection\r\n  public createSelector(selectorName: string | number, initialSelected?: PrimaryKey): Selector<DataType> {\r\n    if (this.selectors[selectorName]) return this.selectors[selectorName];\r\n    const selector = this.Selector(initialSelected).key(selectorName as string);\r\n    this.selectors[selectorName] = selector;\r\n    return selector;\r\n  }\r\n\r\n  // save data directly into collection storage\r\n  public saveData(data: DataType, patch?: boolean): PrimaryKey | null {\r\n    let key = this.config.primaryKey;\r\n    if (!data || !data.hasOwnProperty(key)) return null;\r\n    // if the data already exists and config is to patch, patch data\r\n    if (this.data[data[key]] && patch) this.data[data[key]].patch(data, { deep: false });\r\n    // if already exists and no config, overwrite data\r\n    else if (this.data[data[key]]) this.data[data[key]].set(data);\r\n    // otherwise create new data instance\r\n    else this.data[data[key]] = new Data<DataType>(() => this, data);\r\n    this.size++;\r\n    return data[key];\r\n  }\r\n\r\n  /**\r\n   * Collect iterable data into this collection. Note:\r\n   * - Data items must include a primary key (id)\r\n   * @param {(Array<object>|object)} data - Array of data, or single data object\r\n   * @param {(Array<string>|string)} groups - Array of group names or single group name\r\n   */\r\n  public collect(\r\n    items: DataType | Array<DataType>,\r\n    groups?: GroupName | Array<GroupName>,\r\n    config: {\r\n      patch?: boolean;\r\n      method?: 'push' | 'unshift';\r\n      forEachItem?: (item: DataType, key: PrimaryKey, index: number) => void;\r\n    } = {}\r\n  ): void {\r\n    let _items = normalizeArray(items);\r\n    if (!groups) groups = 'default';\r\n    groups = normalizeArray(groups);\r\n\r\n    // if any of the groups don't already exist, create them\r\n    groups.forEach(groupName => !this.groups[groupName] && this.createGroup(groupName));\r\n\r\n    _items.forEach((item, index) => {\r\n      let key = this.saveData(item, config.patch);\r\n      if (config.forEachItem) config.forEachItem(item, key, index);\r\n      if (key === null) return;\r\n      (groups as Array<string>).forEach(groupName => {\r\n        let group = this.groups[groupName];\r\n        if (!group.nextState.includes(key)) group.nextState[config.method || 'push'](key);\r\n      });\r\n    });\r\n\r\n    groups.forEach(groupName => this.instance().runtime.ingest(this.groups[groupName], this.groups[groupName].nextState));\r\n  }\r\n  /**\r\n   * Return an item from this collection by primaryKey as Data instance (extends State)\r\n   * @param {(number|string)} primaryKey - The primary key of the data\r\n   */\r\n  public findById(id: PrimaryKey | State): Data<DataType> {\r\n    if (id instanceof State) id = id.value;\r\n    if (!this.data.hasOwnProperty(id as PrimaryKey)) {\r\n      return new Data(() => this, undefined);\r\n    }\r\n    return this.data[id as PrimaryKey];\r\n  }\r\n\r\n  public getValueById(id: PrimaryKey | State): DataType {\r\n    let data = this.findById(id).value;\r\n    // @ts-ignore\r\n    if (!data) data = {};\r\n    return this.computedFunc ? this.computedFunc(data) : data;\r\n  }\r\n\r\n  /**\r\n   * Return an group from this collection as Group instance (extends State)\r\n   * @param {(number|string)} groupName - The name of your group\r\n   */\r\n  public getGroup(groupName: string | number): Group<DataType> {\r\n    if (this.groups[groupName]) {\r\n      return this.groups[groupName];\r\n    } else {\r\n      return new Group(() => this, [], { name: 'dummy' }); // return empty group\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update data by id in a Pulse Collection\r\n   * @param {(string|number|State)} updateKey - The primary key of the item to update\r\n   * @param {Object} changes - This object will be deep merged with the original\r\n   */\r\n\r\n  public update(updateKey: PrimaryKey | State, changes: Expandable = {}, config: { deep?: boolean } = {}): State {\r\n    // if State instance passed as updateKey grab the value\r\n    if (updateKey instanceof State) updateKey = updateKey.value;\r\n    updateKey = updateKey as PrimaryKey;\r\n\r\n    // if the primary key is changed, this will be true\r\n    let updateDataKey: boolean = false,\r\n      // define aliases\r\n      data = this.data[updateKey],\r\n      primary = this.config.primaryKey;\r\n\r\n    // if the data does not exist\r\n    if (!this.data.hasOwnProperty(updateKey)) return;\r\n\r\n    // create a copy of the value for mutation\r\n    const currentData = data.copy();\r\n\r\n    // if the new object contains a primary key, it means we need to change the primary key\r\n    // on the collection too, however we should defer this until after the new data is ingested into the runtime queue\r\n    if (changes[primary]) updateDataKey = true;\r\n\r\n    // deep merge the new data with the existing data\r\n    const final = config.deep ? deepmerge(currentData, changes) : shallowmerge(currentData, changes);\r\n\r\n    // assign the merged data to the next state of the State and ingest\r\n    data.nextState = final;\r\n    this.instance().runtime.ingest(data);\r\n\r\n    // if the data key has changed move it internally and ammend groups\r\n    if (updateDataKey) this.updateDataKey(currentData[primary], final[primary]);\r\n\r\n    this.rebuildGroupsThatInclude(final[primary]);\r\n\r\n    // return the Data instance\r\n    return this.data[final[primary]];\r\n  }\r\n\r\n  public compute(func: (data: DataType) => DataType): void {\r\n    this.computedFunc = func;\r\n  }\r\n\r\n  public put(primaryKeys: PrimaryKey | Array<PrimaryKey>, groupNames: GroupName | Array<GroupName>, options?: GroupAddOptions) {\r\n    primaryKeys = normalizeArray(primaryKeys);\r\n    groupNames = normalizeArray(groupNames);\r\n\r\n    groupNames.forEach(groupName => {\r\n      if (!this.groups.hasOwnProperty(groupName)) return;\r\n\r\n      (primaryKeys as Array<PrimaryKey>).forEach(key => {\r\n        this.groups[groupName].add(key, options);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * this is an alias function that returns other functions for removing data from a collection\r\n   */\r\n  public remove(primaryKeys: PrimaryKey | Array<PrimaryKey>): RemoveOptions {\r\n    primaryKeys = normalizeArray(primaryKeys);\r\n    return {\r\n      fromGroups: (groups: Array<string>) => this.removeFromGroups(primaryKeys, groups),\r\n      everywhere: () => this.deleteData(primaryKeys, Object.keys(this.groups))\r\n    };\r\n  }\r\n\r\n  public removeFromGroups(primaryKeys: PrimaryKey | Array<PrimaryKey>, groups: GroupName | Array<GroupName>): boolean {\r\n    primaryKeys = normalizeArray(primaryKeys);\r\n    groups = normalizeArray(groups);\r\n    groups.forEach(groupName => {\r\n      (primaryKeys as Array<PrimaryKey>).forEach(primaryKey => {\r\n        if (!this.groups[groupName]) return;\r\n        let group = this.getGroup(groupName);\r\n        group.remove(primaryKey);\r\n      });\r\n    });\r\n    return true;\r\n  }\r\n\r\n  public deleteData(primaryKeys: PrimaryKey | Array<PrimaryKey>, groups: GroupName | Array<GroupName>): boolean {\r\n    primaryKeys = normalizeArray(primaryKeys);\r\n    groups = normalizeArray(groups);\r\n\r\n    primaryKeys.forEach(key => {\r\n      delete this.data[key];\r\n      (groups as Array<GroupName>).forEach(groupName => {\r\n        this.groups[groupName].nextState = this.groups[groupName].nextState.filter(id => id !== key);\r\n      });\r\n    });\r\n\r\n    groups.forEach(groupName => this.instance().runtime.ingest(this.groups[groupName], this.groups[groupName].nextState));\r\n\r\n    return true;\r\n  }\r\n\r\n  private updateDataKey(oldKey: PrimaryKey, newKey: PrimaryKey): void {\r\n    // create copy of data\r\n    const dataCopy = this.data[oldKey];\r\n    // delete old reference\r\n    delete this.data[oldKey];\r\n    // apply the data in storage\r\n    this.data[newKey] = dataCopy;\r\n\r\n    // update groups\r\n    for (let groupName in this.groups) {\r\n      const group = this.getGroup(groupName);\r\n      // if group does not contain oldKey, continue.\r\n      if (!group._value.includes(oldKey)) continue;\r\n      // replace the primaryKey at current index\r\n      group.nextState.splice(group.nextState.indexOf(oldKey), 1, newKey);\r\n      // ingest the group\r\n      this.instance().runtime.ingest(group);\r\n    }\r\n  }\r\n\r\n  public rebuildGroupsThatInclude(primaryKey: PrimaryKey): void {\r\n    this._groups.forEach(group => group.has(primaryKey) && this.instance().runtime.ingest(group));\r\n  }\r\n\r\n  public reset() {\r\n    this.data = {};\r\n    this.size = 0;\r\n    const groups = Object.keys(this.groups);\r\n    groups.forEach(groupName => this.groups[groupName].reset());\r\n  }\r\n}\r\n\r\nexport default Collection;\r\n","import { State, Collection, DefaultDataItem } from '../internal';\r\n\r\nexport class Data<DataType = DefaultDataItem> extends State<DataType> {\r\n  public output: DataType | DefaultDataItem;\r\n  constructor(private collection: () => Collection, data: DataType) {\r\n    super(collection().instance, data);\r\n    this.type(Object);\r\n    // this.name = data && data[collection().config.primaryKey];\r\n  }\r\n}\r\nexport default Data;\r\n\r\n// collection should detect if computed data dependency is own group, if so handle efficiently\r\n","import { Pulse, State, Collection, DefaultDataItem } from '../internal';\r\nimport { defineConfig } from '../utils';\r\n\r\nexport type PrimaryKey = string | number;\r\nexport type GroupName = string | number;\r\nexport type Index = Array<PrimaryKey>;\r\nexport type InstanceContext = (() => Collection) | (() => Pulse);\r\n\r\nexport class Group<DataType = DefaultDataItem> extends State<Array<PrimaryKey>> {\r\n  _masterOutput: Array<DataType> = [];\r\n  missingPrimaryKeys: Array<PrimaryKey> = [];\r\n  computedFunc?: (data: DataType) => DataType;\r\n  collection: () => Collection<DataType>;\r\n  public get index(): Array<PrimaryKey> {\r\n    return this.value;\r\n  }\r\n  public get output(): Array<DataType> {\r\n    if (this.instance().runtime.trackState) this.instance().runtime.foundState.add(this);\r\n    return this._masterOutput;\r\n  }\r\n\r\n  constructor(context: InstanceContext, initialIndex?: Array<PrimaryKey>, config: { name?: string } = {}) {\r\n    // This invokes the parent class with either the collection or the Pulse instance as context\r\n    // This means groups can be created before (or during) a Collection instantiation\r\n    super((context() instanceof Pulse ? context : (context() as Collection<DataType>).instance) as () => Pulse, initialIndex || []);\r\n    if (context() instanceof Collection) this.collection = context as () => Collection<DataType>;\r\n\r\n    if (config.name) this.name = config.name;\r\n\r\n    this.type(Array);\r\n\r\n    this.sideEffects = () => this.build();\r\n\r\n    // initial build\r\n    this.build();\r\n  }\r\n  public build() {\r\n    this.missingPrimaryKeys = [];\r\n    if (!Array.isArray(this._value)) return [];\r\n    let group = this._value\r\n      .map(primaryKey => {\r\n        let data = this.collection().data[primaryKey];\r\n        if (!data) {\r\n          this.missingPrimaryKeys.push(primaryKey);\r\n          return undefined;\r\n        }\r\n        // on each data item in this group, run compute\r\n        if (this.computedFunc) {\r\n          let dataComputed = this.computedFunc(data.copy());\r\n          return dataComputed;\r\n          // use collection level computed func if local does not exist\r\n        } else if (this.collection().computedFunc) {\r\n          let dataComputed = this.collection().computedFunc(data.copy());\r\n          return dataComputed;\r\n        }\r\n\r\n        return data.getPublicValue();\r\n      })\r\n      .filter(item => item !== undefined);\r\n\r\n    // this.dep.dynamic.forEach(state => state.dep.depend(this));\r\n    //@ts-ignore\r\n    this._masterOutput = group;\r\n  }\r\n\r\n  public has(primaryKey: PrimaryKey) {\r\n    return this.value.includes(primaryKey) || false;\r\n  }\r\n\r\n  public get size(): number {\r\n    return this.value.length;\r\n  }\r\n\r\n  public compute(func: (data: DataType) => DataType): void {\r\n    this.computedFunc = func;\r\n  }\r\n\r\n  public add(primaryKey: PrimaryKey, options: GroupAddOptions = {}): this {\r\n    // set defaults\r\n    options = defineConfig(options, { method: 'push', overwrite: true });\r\n    const useIndex = options.atIndex !== undefined;\r\n    const exists = this.nextState.includes(primaryKey);\r\n\r\n    if (options.overwrite) this.nextState = this.nextState.filter(i => i !== primaryKey);\r\n    // if we do not want to overwrite and key already exists in group, exit\r\n    else if (exists) return this;\r\n\r\n    // if atIndex is set, inject at that index.\r\n    if (useIndex) {\r\n      if (options.atIndex > this.nextState.length) options.atIndex = this.nextState.length - 1;\r\n      this.nextState.splice(options.atIndex, 0, primaryKey);\r\n    }\r\n    // push or unshift into state\r\n    else this.nextState[options.method](primaryKey);\r\n\r\n    // send nextState to runtime and return\r\n    this.set();\r\n    return this;\r\n  }\r\n\r\n  public remove(primaryKey: PrimaryKey): this {\r\n    this.nextState = this.nextState.filter(i => i !== primaryKey);\r\n    this.set();\r\n    return this;\r\n  }\r\n}\r\n\r\nexport default Group;\r\n\r\nexport interface GroupAddOptions {\r\n  atIndex?: number; //\r\n  method?: 'unshift' | 'push'; // method to add to group\r\n  overwrite?: boolean; // set to false to leave primary key in place if already present\r\n}\r\n","import { Computed, Collection, DefaultDataItem, Data, GroupObj, SelectorObj, PrimaryKey } from '../internal';\r\n\r\nexport class Selector<DataType = DefaultDataItem, G = GroupObj, S = SelectorObj> extends Computed<DataType> {\r\n  private collection: () => Collection<DataType, G, S>;\r\n  private _masterSelected: PrimaryKey;\r\n  public set id(val: PrimaryKey) {\r\n    this._masterSelected = val;\r\n    this.recompute();\r\n  }\r\n  public get id() {\r\n    return this._masterSelected;\r\n  }\r\n  constructor(collection: () => Collection<DataType, G, S>, key: PrimaryKey) {\r\n    if (!key) key = 0;\r\n    // initialize computed constructor with initial compute state\r\n    super(collection().instance, () => findData<DataType, G, S>(collection(), key));\r\n\r\n    // computed function that returns a given item from collection\r\n    this.func = () => findData<DataType, G, S>(collection(), this._masterSelected);\r\n\r\n    // alias collection function\r\n    this.collection = collection;\r\n\r\n    this.type(Object);\r\n\r\n    this._masterSelected = key;\r\n  }\r\n  public select(key: PrimaryKey) {\r\n    this.id = key;\r\n  }\r\n  // custom override for the State persist function\r\n  public persist(key?: string) {\r\n    this.persistState = true;\r\n    this.instance().storage.handleStatePersist(this, key);\r\n    return this;\r\n  }\r\n  public getPersistableValue() {\r\n    return this.id;\r\n  }\r\n}\r\n\r\nexport default Selector;\r\n\r\nfunction findData<DataType, G, S>(collection: Collection<DataType, G, S>, key: PrimaryKey) {\r\n  let data = collection.findById(key).value;\r\n  // if data is not found, create placeholder data, so that when real data is collected it maintains connection\r\n  if (!data) {\r\n    // this could be improved by storing temp references outside data object in collection\r\n    collection.data[key] = new Data<DataType>(() => collection, { id: key } as any);\r\n    data = collection.findById(key).value;\r\n  } else {\r\n    // If we have a computed function, run it before returning the data.\r\n    data = collection.computedFunc ? collection.computedFunc(data) : data;\r\n  }\r\n  return data;\r\n}","import { Pulse, State, SetFunc } from './internal';\r\n\r\nexport class Computed<ComputedValueType = any> extends State<ComputedValueType> {\r\n  // private cleanup: Set<State> = new Set();\r\n  public set value(val: ComputedValueType) {\r\n    console.error('Error: Can not mutate Computed value, please use recompute()');\r\n  }\r\n\r\n  public get value(): ComputedValueType {\r\n    return super.value;\r\n  }\r\n\r\n  public set bind(val: ComputedValueType) {\r\n    console.error('Error: Can not bind Computed value');\r\n  }\r\n\r\n  constructor(public instance: () => Pulse, public func: () => ComputedValueType, public deps?: Array<State>) {\r\n    super(instance, instance().config.computedDefault || null);\r\n\r\n    if (deps) deps.forEach(state => state.dep.depend(this));\r\n\r\n    // if Core will not be used, compute immediately\r\n    if (instance().config.noCore === true) this.recompute();\r\n  }\r\n\r\n  public computeValue(): ComputedValueType | SetFunc<ComputedValueType> {\r\n    if (this.deps) return this.func();\r\n\r\n    this.instance().runtime.trackState = true;\r\n\r\n    const computed = this.func();\r\n    let dependents = this.instance().runtime.getFoundState();\r\n    dependents.forEach(state => state.dep.depend(this));\r\n    return computed;\r\n  }\r\n\r\n  public recompute(): void {\r\n    this.set(this.computeValue());\r\n  }\r\n\r\n  public reset(): this {\r\n    super.reset();\r\n    this.recompute();\r\n    return this;\r\n  }\r\n\r\n  public patch() {\r\n    console.error('Error, can not use patch method on Computed since the value is dynamic.');\r\n    return this;\r\n  }\r\n\r\n  public persist(key?: string): this {\r\n    console.error('Computed state can not be persisted, remove call to .persist()', key);\r\n    return this;\r\n  }\r\n}\r\n\r\nexport default Computed;\r\n","import { Collection, State, Computed, Event } from './internal';\r\n\r\nexport type StateObj = { [key: string]: State | Computed };\r\nexport type FuncObj = { [key: string]: (...args: any) => any };\r\nexport type EventObj = { [key: string]: Event };\r\nexport type AnyObj = { [key: string]: any };\r\n\r\n//\r\nexport interface ControllerConfig {\r\n  name?: string;\r\n  root: { [key: string]: any };\r\n  state: StateObj;\r\n  collection: Collection<any>;\r\n  collections: { [key: string]: Collection<any> };\r\n  events: EventObj;\r\n  actions: FuncObj;\r\n  helpers: FuncObj;\r\n  routes: FuncObj;\r\n}\r\n\r\nexport class Controller<O extends Partial<ControllerConfig>> {\r\n  public name?: string;\r\n  public config: O;\r\n\r\n  // expose State tree\r\n  public state: this['config']['state'];\r\n  // primary collection\r\n  public collection: this['config']['collection'];\r\n  public collections: this['config']['collections'];\r\n  // alias groups and selectors for primary collection\r\n  public groups: this['config']['collection']['groups'];\r\n  public selectors: this['config']['collection']['selectors'];\r\n  // events object\r\n  public events: this['config']['events'];\r\n\r\n  // actions, helpers and routes simply containers for functions\r\n  public actions: this['config']['actions'];\r\n  public helpers: this['config']['helpers'];\r\n  public routes: this['config']['routes'];\r\n\r\n  // convert config to partial type to allow for certain config properties to be excluded\r\n  constructor(config: Partial<O>) {\r\n    this.config = config as Required<O>;\r\n\r\n    // assign every property in config to root, types inferred above at declaration (state, collection etc..)\r\n    for (const sectionName in this.config) this[sectionName as string] = this.config[sectionName];\r\n\r\n    // if primary collection is actually an instance of Collection alias groups and selectors\r\n    if (this.config.collection instanceof Collection) {\r\n      this.groups = this.config.collection.groups;\r\n      this.selectors = this.config.collection.selectors;\r\n    }\r\n\r\n    // assign State keys by property name\r\n    for (const name in this.state)\r\n      if (name && this.state[name] instanceof State) {\r\n        const state: any = this.state[name];\r\n        if (!state.name) state.key(name);\r\n        // assign Event keys by property name\r\n      } else if (name && this.state[name] instanceof Event) {\r\n        const event: any = this.state[name];\r\n        if (!event.config.name) event.config.name = name;\r\n      }\r\n  }\r\n  public root<R extends AnyObj = AnyObj>(bindObj: R): this & R {\r\n    for (const propertyName in bindObj) this[propertyName as string] = bindObj[propertyName];\r\n    return this as this & R;\r\n  }\r\n}\r\n","import { State, SubscriptionContainer } from './internal';\r\n\r\nexport class Dep {\r\n  public deps: Set<any> = new Set();\r\n  public subs: Set<SubscriptionContainer> = new Set();\r\n\r\n  constructor(initialDeps?: Array<Dep>) {\r\n    if (initialDeps) initialDeps.forEach(dep => this.deps.add(dep));\r\n  }\r\n\r\n  public depend(instance: State) {\r\n    if (instance.dep === this) return;\r\n    this.deps.add(instance);\r\n  }\r\n}\r\n\r\nexport default Dep;\r\n","import { Pulse } from './internal';\r\n\r\n// default event payload\r\nexport type EventPayload = { [key: string]: any };\r\n// type of the callback an event should receive\r\nexport type EventCallbackFunc<P = EventPayload> = (payload: P) => void;\r\n// type of the function used as an alias to create an event instance, with a generic for the payload type\r\nexport type CreateEventFunc = <P = EventPayload>(config?: EventConfig<P>) => Event<P>;\r\n// type of the function expected to init many events\r\nexport type EventsObjFunc = (createEventFunc: CreateEventFunc) => { [key: string]: Event };\r\n\r\n// Configuration for event constructor\r\nexport interface EventConfig<P = EventPayload> {\r\n  name?: string;\r\n  maxSubs?: number;\r\n  enabled?: boolean;\r\n  disableAfterUses?: number;\r\n  throttle?: number;\r\n  queue?: boolean;\r\n}\r\n\r\n// Event class\r\nexport class Event<P = EventPayload> {\r\n  // store the callbacks as a set of functions\r\n  private callbacks: Set<EventCallbackFunc<P>> = new Set();\r\n  // store the amount of uses for this event, undefined by default unless set in config\r\n  private uses: number;\r\n  private currentTimeout: any | number;\r\n  //\r\n  private queue: Array<P>;\r\n  // should never be defined, but holds reference to the Payload type for useEvent to read\r\n  public payload: P;\r\n\r\n  constructor(public instance: () => Pulse, public config: EventConfig<P> = {}) {\r\n    // initiate uses state if applicable\r\n    if (config.disableAfterUses) this.uses = 0;\r\n    if (config.queue) this.queue = [];\r\n  }\r\n\r\n  // register subscribers\r\n  public on(callback: EventCallbackFunc<P>): () => void {\r\n    // on returns a clean up function, defined here for multiple return points\r\n    const cleanupFunc = () => this.unsub(callback);\r\n\r\n    // if maxSubs is set, and there are less than or equal to the maximum, fail silently.\r\n    if (this.config.maxSubs !== undefined && this.callbacks.size <= this.config.maxSubs) return cleanupFunc;\r\n\r\n    // if destroy after uses is truthy and the uses is less than or equal the destroy amount\r\n    if (this.config.disableAfterUses && this.uses > this.config.disableAfterUses) {\r\n      this.disable();\r\n      return cleanupFunc;\r\n    }\r\n\r\n    // add the callback to Event callback set and return cleanup function\r\n    this.callbacks.add(callback);\r\n    return cleanupFunc;\r\n  }\r\n\r\n  // run all the callbacks in this event and pass the payload\r\n  public emit(payload?: P): void {\r\n    // if Event is disabled block emitting\r\n    if (this.config.enabled !== undefined && !this.config.enabled) return;\r\n\r\n    if (this.config.throttle) {\r\n      this.handleThrottle(payload);\r\n    } else {\r\n      this.emitter(payload);\r\n    }\r\n  }\r\n\r\n  public disable(): void {\r\n    this.config.enabled = false;\r\n  }\r\n\r\n  // Private functions\r\n  private emitter(payload: P) {\r\n    // foreach callback, invoke the saved function\r\n    this.callbacks.forEach(callback => callback(payload));\r\n    // increment the uses if\r\n    if (this.uses !== undefined) this.uses++;\r\n  }\r\n\r\n  private unsub(callback: EventCallbackFunc<P>): void {\r\n    this.callbacks.delete(callback);\r\n  }\r\n\r\n  private handleThrottle(payload: P): void {\r\n    const throttling = this.currentTimeout !== undefined;\r\n    // throttling with a queue? push to queue and reset timeout\r\n    if (throttling && this.queue) {\r\n      this.queue.push(payload);\r\n      clearTimeout(this.currentTimeout);\r\n      this.currentTimeout = undefined;\r\n    }\r\n\r\n    // throttling without a queue? exit\r\n    else if (throttling) return;\r\n    // throttle is not running, begin timeout chain\r\n    else {\r\n      const looper = (payload: P) => {\r\n        this.currentTimeout = setTimeout(() => {\r\n          this.currentTimeout = undefined;\r\n          // emit the event with passed in payload\r\n          this.emitter(payload);\r\n          // if using the queue grab the next payload from the queue and loop back with a new timer\r\n          if (this.queue && this.queue.length > 0) looper(this.queue.shift());\r\n        }, this.config.throttle);\r\n      };\r\n      looper(payload);\r\n    }\r\n    //\r\n    return;\r\n  }\r\n}\r\n","function isNonNullObject(value) {\r\n  return !!value && typeof value === 'object';\r\n}\r\n\r\nfunction isSpecial(value) {\r\n  var stringValue = Object.prototype.toString.call(value);\r\n\r\n  return (\r\n    stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value)\r\n  );\r\n}\r\n\r\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\r\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\r\n\r\nfunction isReactElement(value) {\r\n  return value.$$typeof === REACT_ELEMENT_TYPE;\r\n}\r\n\r\nfunction defaultIsMergeableObject(value) {\r\n  return isNonNullObject(value) && !isSpecial(value);\r\n}\r\n\r\nfunction emptyTarget(val) {\r\n  return Array.isArray(val) ? [] : {};\r\n}\r\n\r\nfunction cloneUnlessOtherwiseSpecified(value, options) {\r\n  return options.clone !== false && options.isMergeableObject(value)\r\n    ? deepmerge(emptyTarget(value), value, options)\r\n    : value;\r\n}\r\n\r\nfunction defaultArrayMerge(target, source, options) {\r\n  return target.concat(source).map(function(element) {\r\n    return cloneUnlessOtherwiseSpecified(element, options);\r\n  });\r\n}\r\n\r\nfunction getMergeFunction(key, options) {\r\n  if (!options.customMerge) {\r\n    return deepmerge;\r\n  }\r\n  var customMerge = options.customMerge(key);\r\n  return typeof customMerge === 'function' ? customMerge : deepmerge;\r\n}\r\n\r\nfunction getEnumerableOwnPropertySymbols(target: any): any {\r\n  return Object.getOwnPropertySymbols\r\n    ? Object.getOwnPropertySymbols(target).filter(function(symbol) {\r\n        return target.propertyIsEnumerable(symbol);\r\n      })\r\n    : [];\r\n}\r\n\r\nfunction getKeys(target) {\r\n  return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));\r\n}\r\n\r\nfunction propertyIsOnObject(object, property) {\r\n  try {\r\n    return property in object;\r\n  } catch (_) {\r\n    return false;\r\n  }\r\n}\r\n\r\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\r\nfunction propertyIsUnsafe(target, key) {\r\n  return (\r\n    propertyIsOnObject(target, key) && // Properties are safe to merge if they don't exist in the target yet,\r\n    !(\r\n      Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key) // unsafe if they exist up the prototype chain,\r\n    )\r\n  ); // and also unsafe if they're nonenumerable.\r\n}\r\n\r\nfunction mergeObject(target, source, options) {\r\n  var destination = {};\r\n  if (options.isMergeableObject(target)) {\r\n    getKeys(target).forEach(function(key) {\r\n      destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\r\n    });\r\n  }\r\n  getKeys(source).forEach(function(key) {\r\n    if (propertyIsUnsafe(target, key)) {\r\n      return;\r\n    }\r\n\r\n    if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\r\n      destination[key] = getMergeFunction(key, options)(target[key], source[key], options);\r\n    } else {\r\n      destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\r\n    }\r\n  });\r\n  return destination;\r\n}\r\n\r\nexport function deepmerge(target, source, options?) {\r\n  options = options || {};\r\n  options.arrayMerge = options.arrayMerge || defaultArrayMerge;\r\n  options.isMergeableObject = options.isMergeableObject || defaultIsMergeableObject;\r\n  // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\r\n  // implementations can use it. The caller may not replace it.\r\n  options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\r\n\r\n  var sourceIsArray = Array.isArray(source);\r\n  var targetIsArray = Array.isArray(target);\r\n  var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\r\n\r\n  if (!sourceAndTargetTypesMatch) {\r\n    return cloneUnlessOtherwiseSpecified(source, options);\r\n  } else if (sourceIsArray) {\r\n    return options.arrayMerge(target, source, options);\r\n  } else {\r\n    return mergeObject(target, source, options);\r\n  }\r\n}\r\n","import { isWatchableObject } from './isWatchableObj';\r\n\r\n/**\r\n * A helper function to extract all instances of a target instance from an object\r\n * If this function fails, it will do so silently, so it can be safely used without much knowledge of `inObj`.\r\n * @param findClass Class to extract instances of\r\n * @param inObj Object to find all instances of `findType` within\r\n */\r\nexport function extractAll<I extends new (...args: any) => any, O>(findClass: I, inObj: O): Set<InstanceType<I>> {\r\n  // safety net: object passed is not an obj, but rather an instance of the testClass in question, return that\r\n  if (inObj instanceof findClass) return new Set([findClass]) as Set<InstanceType<I>>;\r\n  // safety net: if type passed is not iterable, return empty set\r\n  if (typeof inObj !== 'object') return new Set<InstanceType<I>>();\r\n\r\n  // define return Set with typeof testClass\r\n  const found: Set<InstanceType<I>> = new Set();\r\n  // storage for the look function's state\r\n  let next = [inObj];\r\n  function look() {\r\n    let _next = [...next]; // copy last state\r\n    next = []; // reset the original state\r\n    _next.forEach(o => {\r\n      const typelessObject: any = o;\r\n      // look at every property in object\r\n      for (let property in o) {\r\n        // check if instance type of class\r\n        if (o[property] instanceof findClass) found.add(typelessObject[property]);\r\n        // otherwise if object, store child object for next loop\r\n        else if (isWatchableObject(o[property])) next.push(typelessObject[property]);\r\n      }\r\n    });\r\n    // if next state has items, loop function\r\n    if (next.length > 0) look();\r\n  }\r\n  look();\r\n  return found;\r\n}\r\n","export function isWatchableObject(value) {\r\n  function isHTMLElement(obj) {\r\n    try {\r\n      return obj instanceof HTMLElement;\r\n    } catch (e) {\r\n      return typeof obj === 'object' && obj.nodeType === 1 && typeof obj.style === 'object' && typeof obj.ownerDocument === 'object';\r\n    }\r\n  }\r\n  let type = typeof value;\r\n  return value != null && type == 'object' && !isHTMLElement(value) && !Array.isArray(value);\r\n}\r\n","export * from './internal';\r\n\r\nimport { Pulse } from './internal';\r\n\r\nexport default Pulse;\r\n","import { Pulse, State, Event, EventCallbackFunc, SubscriptionContainer } from '../internal';\r\nimport { normalizeDeps, getPulseInstance } from '../utils';\r\n\r\nexport function PulseHOC(ReactComponent: any, deps?: Array<State> | { [key: string]: State } | State, pulseInstance?: Pulse) {\r\n  let depsArray: Array<State>;\r\n  let depsObject: { [key: string]: State };\r\n\r\n  if (deps instanceof State || Array.isArray(deps)) {\r\n    // Normalize Dependencies\r\n    depsArray = normalizeDeps(deps || []);\r\n\r\n    // Get Pulse Instance\r\n    if (!pulseInstance) {\r\n      if (depsArray.length > 0) {\r\n        const tempPulseInstance = getPulseInstance(depsArray[0]);\r\n        pulseInstance = tempPulseInstance || undefined;\r\n      } else {\r\n        console.warn(\"Pulse: Please don't pass an empty array!\");\r\n      }\r\n    }\r\n  } else if (typeof deps === 'object') {\r\n    depsObject = deps;\r\n\r\n    // Get Pulse Instance\r\n    if (!pulseInstance) {\r\n      const objectKeys = Object.keys(depsObject);\r\n      if (objectKeys.length > 0) {\r\n        const tempPulseInstance = getPulseInstance(depsObject[objectKeys[0]]);\r\n        pulseInstance = tempPulseInstance || undefined;\r\n      } else {\r\n        console.warn(\"Pulse: Please don't pass an empty object!\");\r\n      }\r\n    }\r\n  } else {\r\n    console.error('Pulse: No Valid PulseHOC properties');\r\n    return ReactComponent;\r\n  }\r\n\r\n  // Check if pulse Instance exists\r\n  if (!pulseInstance) {\r\n    console.error('Pulse: Failed to get Pulse Instance');\r\n    return ReactComponent;\r\n  }\r\n\r\n  // Get React constructor\r\n  const React = pulseInstance.integration?.frameworkConstructor;\r\n  if (!React) {\r\n    console.error('Pulse: Failed to get Framework Constructor');\r\n    return ReactComponent;\r\n  }\r\n\r\n  return class extends React.Component {\r\n    public componentContainer: SubscriptionContainer | null = null; // Will be set in registerSubscription (sub.ts)\r\n\r\n    public updatedProps = this.props;\r\n\r\n    constructor(props: any) {\r\n      super(props);\r\n\r\n      // Create HOC based Subscription with Array (Rerenders will here be caused via force Update)\r\n      if (depsArray) pulseInstance?.subController.subscribeWithSubsArray(this, depsArray);\r\n\r\n      // Create HOC based Subscription with Object\r\n      if (depsObject) {\r\n        const response = pulseInstance?.subController.subscribeWithSubsObject(this, depsObject);\r\n        this.updatedProps = {\r\n          ...props,\r\n          ...response?.props\r\n        };\r\n\r\n        // Defines State for causing rerender (will be called in updateMethod)\r\n        this.state = depsObject;\r\n      }\r\n    }\r\n\r\n    componentDidMount() {\r\n      if (pulseInstance?.config.waitForMount) pulseInstance?.subController.mount(this);\r\n    }\r\n\r\n    componentWillUnmount() {\r\n      pulseInstance?.subController.unsubscribe(this);\r\n    }\r\n\r\n    render() {\r\n      return React.createElement(ReactComponent, this.updatedProps);\r\n    }\r\n  };\r\n}\r\n\r\ntype PulseHookArray<T> = { [K in keyof T]: T[K] extends State<infer U> ? U : never };\r\ntype PulseHookResult<T> = T extends State<infer U> ? U : never;\r\n\r\n// array-argument syntax\r\nexport function usePulse<X extends State<any>[]>(deps: X | [], pulseInstance?: Pulse): PulseHookArray<X>;\r\n// single-argument syntax\r\nexport function usePulse<X extends State<any>>(deps: X, pulseInstance?: Pulse): PulseHookResult<X>;\r\n\r\nexport function usePulse<X extends Array<State<any>>>(deps: X | [] | State, pulseInstance?: Pulse): PulseHookArray<X> | PulseHookResult<X> {\r\n  // Normalize Dependencies\r\n  let depsArray = normalizeDeps(deps) as PulseHookArray<X>;\r\n\r\n  // Get Pulse Instance\r\n  if (!pulseInstance) {\r\n    const tempPulseInstance = getPulseInstance(depsArray[0]);\r\n    if (!tempPulseInstance) {\r\n      console.error('Pulse: Failed to get Pulse Instance');\r\n      return undefined;\r\n    }\r\n    pulseInstance = tempPulseInstance;\r\n  }\r\n\r\n  // Get React constructor\r\n  const React = pulseInstance.integration?.frameworkConstructor;\r\n  if (!React) {\r\n    console.error('Pulse: Failed to get Framework Constructor');\r\n    return undefined;\r\n  }\r\n\r\n  /* TODO: depsArrayFinal doesn't get used so idk if its necessary\r\n\tlet depsArrayFinal: Array<State> = [];\r\n\t// this allows you to pass in a keyed object of States and subscribe to all  State within the first level of the object. Useful if you wish to subscribe a component to several State instances at the same time.\r\n\tdepsArray.forEach(dep => {\r\n\t\tif (dep instanceof State) depsArrayFinal.push(dep);\r\n\t\telse if (typeof dep === 'object')\r\n\t\t\tfor (let d in dep as keyedState) {\r\n\t\t\t\tif ((dep[d] as any) instanceof State) depsArrayFinal.push(dep[d]);\r\n\t\t\t}\r\n\t});\r\n\t */\r\n\r\n  // this is a trigger state used to force the component to re-render\r\n  const [_, set_] = React.useState({});\r\n\r\n  React.useEffect(function () {\r\n    // Create a callback base subscription, Callback invokes re-render Trigger\r\n    const subscriptionContainer = pulseInstance?.subController.subscribeWithSubsArray(() => {\r\n      set_({});\r\n    }, depsArray);\r\n\r\n    // Unsubscribe on Unmount\r\n    return () => pulseInstance?.subController.unsubscribe(subscriptionContainer);\r\n  }, []);\r\n\r\n  // Return Public Value of State\r\n  if (!Array.isArray(deps) && depsArray.length === 1) return depsArray[0].getPublicValue();\r\n\r\n  // Return Public Value of State in Array\r\n  return depsArray.map(dep => {\r\n    return dep.getPublicValue();\r\n  }) as PulseHookArray<X>;\r\n}\r\n\r\n// useEvent helper for using Events inside React components as hooks\r\nexport function useEvent<E extends Event>(event: E, callback: EventCallbackFunc<E['payload']>, pulseInstance?: Pulse) {\r\n  // get the instance of Pulse\r\n  if (!pulseInstance) pulseInstance = event.instance();\r\n  // get React integration\r\n  const React = pulseInstance.integration?.frameworkConstructor;\r\n  React.useEffect(() => {\r\n    // call the event on component mount\r\n    const unsub = event.on(callback);\r\n    // remove the event on component unmount\r\n    return () => unsub();\r\n  }, []);\r\n}\r\n\r\nexport default {\r\n  name: 'react',\r\n  bind(pulseInstance: Pulse) {\r\n    //\r\n    // pulseInstance.React = (instance: any, deps: Array<State>) =>\r\n    //   PulseHOC(instance, deps, pulseInstance);\r\n    // // usePulse is able to get its context from the state passed in, below is redundant\r\n    // pulseInstance.usePulse = (deps: Array<State>) => usePulse(deps, pulseInstance);\r\n  },\r\n  updateMethod(componentInstance: any, updatedData: Object) {\r\n    // UpdatedData will be empty if the PulseHOC doesn't get an object as deps\r\n\r\n    if (Object.keys(updatedData).length !== 0) {\r\n      // Update Props\r\n      componentInstance.updatedProps = { ...componentInstance.updatedProps, ...updatedData };\r\n\r\n      // Set State (Rerender)\r\n      componentInstance.setState(updatedData);\r\n    } else {\r\n      // Force Update (Rerender)\r\n      componentInstance.forceUpdate();\r\n    }\r\n  },\r\n  onReady(pulseInstance: any | Pulse) {\r\n    // TODO is the onReady really necessary.. because I can't find a position where it get called\r\n    // pulseInstance.usePulse = (deps: Array<State> | State) => usePulse(deps, pulseInstance);\r\n  }\r\n};\r\n","import { Pulse } from '../internal';\r\nimport reactIntegration from './react.integration';\r\nimport vueIntegration from './vue.integration';\r\n\r\nexport interface Integration {\r\n  ready?: boolean;\r\n  frameworkConstructor?: any;\r\n  name?: any;\r\n  bind?: Function;\r\n  updateMethod?: Function;\r\n  wrapper?: Function;\r\n  onReady?: Function;\r\n}\r\n\r\n// This gets assigned to the constructor Pulse.integration\r\nconst integration: Integration = {\r\n  ready: false\r\n};\r\n\r\nexport function use(plugin: any, pulseInstance: Pulse) {\r\n  const frameworkName = getFrameworkName(plugin);\r\n\r\n  switch (frameworkName) {\r\n    case 'react':\r\n      integrate(reactIntegration, 'react');\r\n      break;\r\n    case 'vue':\r\n      integrate(vueIntegration, 'vue');\r\n      break;\r\n    case 'custom':\r\n      if (validateCustomFramework(plugin as Integration)) integrate(plugin, 'custom');\r\n      break;\r\n  }\r\n\r\n  // assign framework constructor to integration object\r\n  if (frameworkName !== 'custom') integration.frameworkConstructor = plugin;\r\n\r\n  // Inject into static property of constructor\r\n  pulseInstance.integration = integration;\r\n\r\n  // if the integration is ready, call bind otherwise warn user\r\n  if (integration.ready) integration.bind(pulseInstance);\r\n  else {\r\n    console.error(`Pulse: Failed to integrate with framework! It's possible you didn't call Pulse.use() before new Pulse.`);\r\n    // TODO: in some cases one might want to use Pulse without a framework so consider making this warning only show in dev, and making a config option to hide it entirely.\r\n  }\r\n}\r\n\r\nexport default use;\r\n\r\n//******** HELPERS BELOW *******\r\n\r\nfunction integrate(int: Integration, frameworkName: string) {\r\n  // bind all properties from integration\r\n  Object.keys(int).forEach(property => {\r\n    integration[property] = int[property];\r\n  });\r\n  // assign name and set ready\r\n  integration.name = int.name || frameworkName;\r\n  integration.ready = true;\r\n}\r\n\r\nfunction validateCustomFramework(customIntegration: Integration): boolean {\r\n  let valid: boolean = true;\r\n  // check for required properties\r\n  ['name', 'bind', 'updateData'].forEach(property => {\r\n    if (!customIntegration.hasOwnProperty(property)) valid = false;\r\n  });\r\n  return valid;\r\n}\r\n\r\nfunction getFrameworkName(frameworkConstructor): string {\r\n  let name: string = 'custom';\r\n  if (!frameworkConstructor) return name;\r\n\r\n  // ATTEMPT CHECK FOR REACT\r\n  if (frameworkConstructor.name === 'React' || frameworkConstructor.hasOwnProperty('__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED'))\r\n    return 'react';\r\n\r\n  // ATTEMPT CHECK FOR VUE\r\n  // this check works in dev, but not prod since Vue is a function that returns a constructor in prod, for some reason.\r\n  if (frameworkConstructor.name === 'Vue') return 'vue';\r\n\r\n  if (typeof frameworkConstructor === 'function') {\r\n    return 'vue'; // more performant than below since it's kinda annoying to construct an instance of Vue just to check if it is Vue, but it shouldn't hurt until we add support for more frameworks.\r\n    let maybeVue = new frameworkConstructor();\r\n    if (maybeVue._isVue) return 'vue';\r\n  }\r\n\r\n  return name;\r\n}\r\n","import { Pulse, State } from '../internal';\r\n\r\ntype keyedState = {\r\n  [key: string]: State;\r\n};\r\n\r\nexport default {\r\n  name: 'vue',\r\n  bind(pulseConstructor) {\r\n    pulseConstructor.install = (Vue, options: any) => {\r\n      const pulse = globalThis.__pulse;\r\n\r\n      pulseConstructor._SSOT = {};\r\n\r\n      Object.keys(options).forEach((key, i) => {\r\n        pulseConstructor._SSOT['$' + key] = options[key];\r\n      });\r\n\r\n      Vue.mixin({\r\n        beforeCreate() {\r\n          // bind root properties\r\n          if (pulseConstructor.State) this.State = pulseConstructor.State;\r\n          if (pulseConstructor.Collection) this.Collection = pulseConstructor.Collection;\r\n          if (pulseConstructor.API) this.API = pulseConstructor.API;\r\n          if (pulseConstructor.Computed) this.Computed = pulseConstructor.Computed;\r\n\r\n          if (usePulse) this.usePulse = usePulse.bind(pulseConstructor._SSOT);\r\n\r\n          Object.keys(options).forEach((key, i) => {\r\n            this['$' + key] = pulseConstructor._SSOT['$' + key];\r\n          });\r\n        },\r\n        mounted() {\r\n          // if (this.__pulseUniqueIdentifier && config.waitForMount)\r\n          // \tpulse.mount(this);\r\n        },\r\n        beforeDestroy() {\r\n          // if (this.__pulseUniqueIdentifier && config.autoUnmount)\r\n          // \tglobal.subs.unmount(this);\r\n        }\r\n      });\r\n    };\r\n  },\r\n  updateMethod(componentInstance: any, updatedData: Object) {\r\n    for (let dataKey in updatedData) {\r\n      componentInstance.$set(componentInstance, dataKey, updatedData[dataKey]);\r\n    }\r\n  },\r\n  onReady(pulseInstance: any | Pulse) {\r\n    const Vue = pulseInstance.integration.frameworkConstructor;\r\n    pulseInstance.usePulse = (deps: Array<string> | string) => usePulse(deps, pulseInstance);\r\n    Vue.use(pulseInstance);\r\n  }\r\n};\r\n\r\n/**\r\n *\r\n * @param deps Can either be a string or an array of strings set equal to the same of the pulse objects defined in Vue.use()\r\n * @param pulseInstance The pulse container to look at if you want to use a different SSOT\r\n */\r\nexport function usePulse(deps: Array<string | State | keyedState> | string | State, pulseInstance?: Pulse) {\r\n  enum ReturnType {\r\n    'STRING',\r\n    'STATE',\r\n    'KEYED'\r\n  }\r\n  console.log(this);\r\n\r\n  let depsArray: (string | State | keyedState)[];\r\n  let depsArrayFinal: (State | keyedState)[] = [];\r\n  let depsObjFinal: any = {};\r\n\r\n  if (!Array.isArray(deps)) depsArray = [deps];\r\n  else depsArray = deps;\r\n\r\n  let type: ReturnType;\r\n  depsArray.forEach(dep => {\r\n    if (typeof dep === 'string') {\r\n      if (this['$' + dep]) depsObjFinal[dep] = this['$' + dep];\r\n      if (!type) type = ReturnType.STRING;\r\n    } else if (dep instanceof State) {\r\n      depsArrayFinal.push(dep);\r\n      if (!type) type = ReturnType.STATE;\r\n    } else {\r\n      /// must be a keyedState\r\n      for (let d in dep as keyedState) {\r\n        if ((dep[d] as any) instanceof State) depsArrayFinal.push(dep[d]);\r\n      }\r\n      if (!type) type = ReturnType.KEYED;\r\n    }\r\n  });\r\n\r\n  // let depsArray = normalizeDeps(deps as Array<State>);\r\n  // if (!pulseInstance) pulseInstance = getInstance(depsArray[0]);\r\n\r\n  // // The final list of states and dependancies\r\n\r\n  // // this allows you to pass in a keyed object of States and subscribe to all  State within the first level of the object. Useful if you wish to subscribe a component to several State instances at the same time.\r\n  // depsArray.forEach(dep => {\r\n  // \tif (dep instanceof State) depsArrayFinal.push(dep);\r\n  // \telse if (typeof dep === 'object')\r\n  // \t\tfor (let d in dep as keyedState) {\r\n  // \t\t\tif ((dep[d] as any) instanceof State) depsArrayFinal.push(dep[d]);\r\n  // \t\t}\r\n  // });\r\n\r\n  // get Vue constructor\r\n  if (pulseInstance) {\r\n    const Vue = pulseInstance.integration.frameworkConstructor;\r\n    if (!Vue) return;\r\n  }\r\n\r\n  // return depsArray.map(dep => {\r\n  // \tif (dep instanceof State) return dep.getPublicValue();\r\n  // \treturn dep;\r\n  // });\r\n  if (type === ReturnType.STRING) {\r\n    return depsObjFinal;\r\n  } else if (type === ReturnType.STATE) {\r\n    return depsArrayFinal;\r\n  } else if (type === ReturnType.KEYED) {\r\n    return depsArrayFinal;\r\n  }\r\n}\r\n// export function usePulse(deps: Array<State | keyedState> | State, pulseInstance?: Pulse) {\r\n// \tconsole.log(this);\r\n// \tlet depsArray = normalizeDeps(deps as Array<State>);\r\n// \tif (!pulseInstance) pulseInstance = getInstance(depsArray[0]);\r\n\r\n// \t// The final list of states and dependancies\r\n// \tlet depsArrayFinal: Array<State> = [];\r\n\r\n// \t// this allows you to pass in a keyed object of States and subscribe to all  State within the first level of the object. Useful if you wish to subscribe a component to several State instances at the same time.\r\n// \tdepsArray.forEach(dep => {\r\n// \t\tif (dep instanceof State) depsArrayFinal.push(dep);\r\n// \t\telse if (typeof dep === 'object')\r\n// \t\t\tfor (let d in dep as keyedState) {\r\n// \t\t\t\tif ((dep[d] as any) instanceof State) depsArrayFinal.push(dep[d]);\r\n// \t\t\t}\r\n// \t});\r\n\r\n// \t// get Vue constructor\r\n// \tconst Vue = pulseInstance.integration.frameworkConstructor;\r\n// \tif (!Vue) return;\r\n\r\n// \t// return depsArray.map(dep => {\r\n// \t// \tif (dep instanceof State) return dep.getPublicValue();\r\n// \t// \treturn dep;\r\n// \t// });\r\n// \treturn depsArrayFinal;\r\n// }\r\n","// This file exposes Pulse functions and types to the outside world.\r\n// It also serves as a cyclic dependency workaround.\r\n// All internal Pulse modules must import from here.\r\nexport { Pulse } from './pulse';\r\n\r\n// State\r\nexport { State, StateGroup } from './state';\r\nexport { Computed } from './computed';\r\n\r\n// Collections\r\nexport { Collection } from './collection/collection';\r\nexport { Group } from './collection/group';\r\nexport { Selector } from './collection/selector';\r\nexport { Data } from './collection/data';\r\n\r\n// Controllers\r\nexport { Controller } from './controller';\r\n\r\n// Events\r\nexport { Event } from './event';\r\n\r\n// Status\r\nexport { StatusTracker } from './status';\r\n\r\n// API\r\nexport { API } from './api/api';\r\n\r\n// Internal Classes\r\nexport { Runtime } from './runtime';\r\nexport { Storage } from './storage';\r\nexport { Dep } from './dep';\r\nexport { SubController, ComponentContainer, CallbackContainer } from './sub';\r\n\r\n// Integration\r\nexport { use } from './integrations/use';\r\n\r\n// Helper functions\r\nexport { usePulse, useEvent } from './integrations/react.integration';\r\nexport { PulseHOC } from './integrations/react.integration';\r\nexport { cleanState, resetState } from './utils';\r\nexport { persist } from './storage';\r\nexport { extractAll } from './helpers/extractAll';\r\nexport { isWatchableObject } from './helpers/isWatchableObj';\r\n\r\n// Types\r\nexport { SetFunc } from './state';\r\nexport { SubscriptionContainer } from './sub';\r\nexport { PulseResponse } from './api/api';\r\nexport { PrimaryKey, GroupName, GroupAddOptions } from './collection/group';\r\nexport { ControllerConfig, FuncObj, StateObj } from './controller';\r\nexport { StorageConfig } from './storage';\r\nexport { EventPayload, EventConfig, EventsObjFunc, EventCallbackFunc } from './event';\r\nexport { APIConfig } from './api/api';\r\nexport { GroupObj, DefaultDataItem, SelectorObj, Config } from './collection/collection';\r\nexport { Integration } from './integrations/use';\r\n","// prettier-ignore\r\nimport { State, StateGroup, Computed, Collection, GroupObj, DefaultDataItem, SelectorObj, Config, SubController, Runtime, Storage, Event, EventPayload, EventConfig, EventsObjFunc, StorageConfig, API, APIConfig, Group, Controller, ControllerConfig, FuncObj, StateObj, StatusTracker, use, Integration } from './internal';\r\n\r\nexport interface PulseConfig {\r\n  computedDefault?: any;\r\n  waitForMount?: boolean;\r\n  framework?: any;\r\n  frameworkConstructor?: any;\r\n  storage?: StorageConfig;\r\n  logJobs?: boolean;\r\n  noCore?: boolean;\r\n}\r\n\r\nexport const defaultConfig: PulseConfig = {\r\n  noCore: false\r\n};\r\n\r\ninterface ErrorObject {\r\n  code: number; // if the error was because of a request, this will be the request error code\r\n  message: string;\r\n  action: Function; // reference to action in which the error occurred\r\n  raw: any; // The raw error\r\n}\r\n\r\nexport class Pulse {\r\n  public ready: boolean = false;\r\n  public runtime: Runtime;\r\n  public status: StatusTracker;\r\n  public storage: Storage;\r\n  public controllers: { [key: string]: any } = {};\r\n  public subController: SubController;\r\n  public errorHandlers: Set<(error: ErrorObject) => void> = new Set();\r\n  public integration: Integration = null;\r\n\r\n  // Context reference\r\n  private computed: Set<Computed> = new Set();\r\n  private core: { [key: string]: any } = {};\r\n\r\n  constructor(public config: PulseConfig = defaultConfig) {\r\n    this.subController = new SubController(this);\r\n    // this.status = new StatusTracker(() => this);\r\n    this.runtime = new Runtime(this);\r\n    this.storage = new Storage(() => this, config.storage);\r\n    if (config.framework) this.initFrameworkIntegration(config.framework);\r\n    if (this.config.noCore === true) this.onInstanceReady();\r\n    this.globalBind();\r\n  }\r\n\r\n  public Core<CoreType>(core?: CoreType): CoreType {\r\n    if (!this.ready && core) this.onInstanceReady(core);\r\n    return this.core as CoreType;\r\n  }\r\n\r\n  public Controller<O extends Partial<ControllerConfig>>(config: Partial<O>): Controller<O> {\r\n    return new Controller<O>(config);\r\n  }\r\n\r\n  /**\r\n   * Create Pulse state\r\n   * @param initialState Any - the value to initialize a State instance with\r\n   */\r\n  public State<T>(initial: T) {\r\n    return new State<T>(() => this, initial);\r\n  }\r\n  /**\r\n   * Create a Pulse computed function\r\n   * @param deps Array - An array of state items to depend on\r\n   * @param func Function - A function where the return value is the state, ran every time a dep changes\r\n   */\r\n  public Computed<T = any>(func: () => any, deps?: Array<any>) {\r\n    const computed = new Computed<T>(() => this, func, deps);\r\n    this.computed.add(computed);\r\n    return computed;\r\n  }\r\n\r\n  /**\r\n   * Create a Pulse collection with automatic type inferring\r\n   * @param config object | function returning object\r\n   * @param config.primaryKey string - The primary key for the collection.\r\n   * @param config.groups object - Define groups for this collection.\r\n   */\r\n  public Collection<DataType = DefaultDataItem>() {\r\n    return <G = GroupObj, S = SelectorObj>(config: Config<DataType, G, S>) => {\r\n      return new Collection<DataType, G, S>(() => this, config);\r\n    };\r\n  }\r\n  /**\r\n   * Create a Pulse Action\r\n   */\r\n  public Action(func: Function) {\r\n    return () => {\r\n      const returnValue = func();\r\n\r\n      return returnValue;\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create Pulse API\r\n   * @param config Object\r\n   * @param config.options Object - Typescript default: RequestInit (headers, credentials, mode, etc...)\r\n   * @param config.baseURL String - Url to prepend to endpoints (without trailing slash)\r\n   * @param config.timeout Number - Time to wait for request before throwing error\r\n   */\r\n  public API(config: APIConfig) {\r\n    return new API(config);\r\n  }\r\n\r\n  /**\r\n   * Create a Pulse Event\r\n   */\r\n  public Event<P = EventPayload>(config?: EventConfig<P>) {\r\n    return new Event(() => this, config);\r\n  }\r\n\r\n  /**\r\n   * Create multiple Pulse Events simultaneously while maintaining type safety\r\n   */\r\n  public EventGroup<E extends EventsObjFunc>(eventsFunc?: E): ReturnType<E> {\r\n    // invoke the EventsObjFunc and pass in the CreateEventFunc\r\n    const eventObj = eventsFunc(config => new Event(() => this, config));\r\n    // assign name from key if undefined in EventConfig\r\n    for (const eventName in eventObj) if (!eventObj[eventName].config.name) eventObj[eventName].config.name = eventName;\r\n    // return the object and cast return value\r\n    return eventObj as ReturnType<E>;\r\n  }\r\n\r\n  public Storage(config: StorageConfig): void {\r\n    return this.setStorage(config);\r\n  }\r\n\r\n  /**\r\n   * Create many Pulse states at the same time\r\n   * @param stateGroup Object with keys as state name and values as initial state\r\n   */\r\n  public StateGroup(stateGroup: any) {\r\n    return StateGroup(() => this, stateGroup);\r\n  }\r\n\r\n  /**\r\n   * Create a Pulse Error\r\n   */\r\n  public Error(error: any, code?: string) {}\r\n\r\n  /**\r\n   * Reset to initial state.\r\n   * - Supports: State, Collections and Groups\r\n   * - Removes persisted state from storage.\r\n   * @param Items Array of items to reset\r\n   */\r\n  public reset(items: Array<State | Group | Collection>): void {}\r\n\r\n  /**\r\n   * onError handler\r\n   */\r\n  public onError(handler: (error: ErrorObject) => void) {}\r\n\r\n  /**\r\n   * nextPulse helper function\r\n   */\r\n  public nextPulse(callback: () => any): void {\r\n    this.runtime.nextPulse(callback);\r\n  }\r\n\r\n  // INTERNAL FUNCTIONS\r\n  private onInstanceReady(core?: { [key: string]: any }) {\r\n    this.ready = true;\r\n\r\n    // Copy core object structure without destroying this.core object reference\r\n    if (core) for (let p in core) this.core[p] = core[p];\r\n\r\n    this.computed.forEach(instance => instance.recompute());\r\n  }\r\n  public initFrameworkIntegration(frameworkConstructor: any) {\r\n    use(frameworkConstructor, this);\r\n  }\r\n  public with(frameworkConstructor: any): this {\r\n    this.initFrameworkIntegration(frameworkConstructor);\r\n    return this;\r\n  }\r\n\r\n  public setStorage(config: StorageConfig): void {\r\n    const persistedState = this.storage.persistedState;\r\n    this.storage = new Storage(() => this, config);\r\n    this.storage.persistedState = persistedState;\r\n    this.storage.persistedState.forEach(state => state.persist(state.name));\r\n  }\r\n\r\n  /**\r\n   * Global reference to the first pulse instance created this runtime\r\n   */\r\n  private globalBind() {\r\n    try {\r\n      if (!globalThis.__pulse__) globalThis.__pulse__ = Pulse;\r\n      if (!globalThis.__pulse__app) globalThis.__pulse__app = this;\r\n    } catch (error) {\r\n      // fail silently\r\n    }\r\n  }\r\n}\r\n\r\nexport default Pulse;\r\n","import { Pulse, State, Computed, CallbackContainer, SubscriptionContainer } from './internal';\r\nimport { copy } from './utils';\r\n\r\nexport interface JobInterface {\r\n  state: State;\r\n  newStateValue?: any;\r\n  background?: boolean;\r\n}\r\n\r\nexport interface JobConfigInterface {\r\n  perform?: boolean;\r\n  background?: boolean;\r\n}\r\n\r\nexport class Runtime {\r\n  public instance: () => Pulse;\r\n\r\n  // queue system\r\n  public currentJob: JobInterface | null = null;\r\n  private jobsQueue: Array<JobInterface> = [];\r\n  private jobsToRerender: Array<JobInterface> = [];\r\n  private tasksOnceComplete: Array<() => any> = [];\r\n\r\n  // used for tracking computed dependencies\r\n  public trackState: boolean = false;\r\n  public foundState: Set<State> = new Set();\r\n\r\n  constructor(pulseInstance: Pulse) {\r\n    this.instance = () => pulseInstance;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   * Creates a Job out of State and new Value and than add it to a job queue\r\n   */\r\n  public ingest(state: State, newStateValue?: any, options: JobConfigInterface = { perform: true, background: false }): void {\r\n    // Create Job\r\n    const job: JobInterface = { state: state, newStateValue: newStateValue, background: options?.background };\r\n\r\n    // grab nextState if newState not passed, compute if needed\r\n    if (newStateValue === undefined) {\r\n      job.newStateValue =\r\n        job.state instanceof Computed\r\n          ? // if computed, recompute value\r\n            job.state.computeValue()\r\n          : // otherwise, default to nextState\r\n            job.state.nextState;\r\n    }\r\n\r\n    // Push the Job to the Queue (the queue will then processed)\r\n    this.jobsQueue.push(job);\r\n\r\n    // Perform the Job\r\n    if (options?.perform) {\r\n      const performJob = this.jobsQueue.shift();\r\n      if (performJob) this.perform(performJob);\r\n      else console.warn('Pulse: Failed to perform Job ', job);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   * Perform a State Update\r\n   */\r\n  private perform(job: JobInterface): void {\r\n    // Set Job to current\r\n    this.currentJob = job;\r\n\r\n    // Set Previous State\r\n    job.state.previousState = copy(job.state._value);\r\n\r\n    // Write new value into the State\r\n    job.state.privateWrite(job.newStateValue);\r\n\r\n    // Perform SideEffects such as watcher functions\r\n    this.sideEffects(job.state);\r\n\r\n    // Set Job as completed (The deps and subs of completed jobs will be updated)\r\n    if (!job.background) this.jobsToRerender.push(job);\r\n\r\n    // Reset Current Job\r\n    this.currentJob = null;\r\n\r\n    // Logging\r\n    if (this.instance().config.logJobs) console.log(`Pulse: Completed Job(${job.state.name})`, job);\r\n\r\n    // Continue the Loop and perform the next job.. if no job is left update the Subscribers for each completed job\r\n    if (this.jobsQueue.length > 0) this.perform(this.jobsQueue.shift());\r\n    else {\r\n      setTimeout(() => {\r\n        // Cause rerender on Subscribers\r\n        this.updateSubscribers();\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * SideEffects are sideEffects of the perform function.. for instance the watchers\r\n   */\r\n  private sideEffects(state: State) {\r\n    let dep = state.dep;\r\n    // this should not be used on root state class as it would be overwritten by extensions\r\n    // this is used mainly to cause group to generate its output after changing\r\n    if (typeof state.sideEffects === 'function') state.sideEffects();\r\n\r\n    // Call Watchers\r\n    for (let watcher in state.watchers) if (typeof state.watchers[watcher] === 'function') state.watchers[watcher](state.getPublicValue());\r\n\r\n    // Ingest dependents (Perform is false because it will be performed anyway after this sideEffect)\r\n    dep.deps.forEach(state => this.ingest(state, undefined, { perform: false }));\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   * This will be update all Subscribers of complete jobs\r\n   */\r\n  private updateSubscribers(): void {\r\n    // Check if Pulse has an integration because its useless to go trough this process without framework\r\n    // It won't happen anything because the state has no subs.. but this check here will maybe improve the performance\r\n    if (!this.instance().integration) {\r\n      this.jobsToRerender = [];\r\n      // TODO maybe a warning but if you want to use PulseJS without framework this might get annoying\r\n      return;\r\n    }\r\n\r\n    // Subscriptions that has to be updated\r\n    const subscriptionsToUpdate: Set<SubscriptionContainer> = new Set<SubscriptionContainer>();\r\n\r\n    // Map through Jobs to Rerender\r\n    this.jobsToRerender.forEach(job =>\r\n      // Map through subs of the current Job State\r\n      job.state.dep.subs.forEach(subscriptionContainer => {\r\n        // Check if subscriptionContainer is ready\r\n        if (!subscriptionContainer.ready) console.warn(\"Pulse: SubscriptionContainer isn't ready yet \", subscriptionContainer);\r\n\r\n        // For a Container that require props to be passed\r\n        if (subscriptionContainer.passProps) {\r\n          let localKey: string | null = null;\r\n\r\n          // Find the local Key for this update by comparing the State instance from this Job to the State instances in the propStates object\r\n          for (let key in subscriptionContainer.propStates) if (subscriptionContainer.propStates[key] === job.state) localKey = key;\r\n\r\n          // If matching key is found push it into the SubscriptionContainer propKeysChanged where it later will be build to an changed prop object\r\n          if (localKey) subscriptionContainer.propKeysChanged.push(localKey);\r\n        }\r\n        // Add sub to subscriptions to Update\r\n        subscriptionsToUpdate.add(subscriptionContainer);\r\n      })\r\n    );\r\n\r\n    // Perform Component or Callback updates\r\n    // TODO maybe add a unique key to a component and if its the same don't cause a rerender for both -> performance optimization\r\n    subscriptionsToUpdate.forEach(subscriptionContainer => {\r\n      // If Callback based subscription call the Callback Function\r\n      if (subscriptionContainer instanceof CallbackContainer) {\r\n        subscriptionContainer.callback();\r\n        return;\r\n      }\r\n\r\n      // If Component based subscription call the updateMethod which every framework has to define\r\n      if (this.instance().integration?.updateMethod)\r\n        this.instance().integration?.updateMethod(subscriptionContainer.component, this.formatChangedPropKeys(subscriptionContainer));\r\n    });\r\n\r\n    // Log Job\r\n    if (this.instance().config.logJobs && subscriptionsToUpdate.size > 0) console.log('Pulse: Rerendered Components ', subscriptionsToUpdate);\r\n\r\n    // Reset Jobs to Rerender\r\n    this.jobsToRerender = [];\r\n\r\n    // Run any tasks for next runtime\r\n    this.tasksOnceComplete.forEach(task => typeof task === 'function' && task());\r\n    this.tasksOnceComplete = [];\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   * Builds an object out of propKeysChanged in the SubscriptionContainer\r\n   */\r\n  public formatChangedPropKeys(subscriptionContainer: SubscriptionContainer): { [key: string]: any } {\r\n    const finalObject: { [key: string]: any } = {};\r\n\r\n    // Build Object\r\n    subscriptionContainer.propKeysChanged.forEach(changedKey => {\r\n      if (subscriptionContainer.propStates) finalObject[changedKey] = subscriptionContainer.propStates[changedKey].value;\r\n    });\r\n\r\n    return finalObject;\r\n  }\r\n\r\n  public getFoundState() {\r\n    this.trackState = false;\r\n    const ret = this.foundState;\r\n    this.foundState = new Set();\r\n    return ret;\r\n  }\r\n\r\n  public nextPulse(callback: () => any) {\r\n    this.tasksOnceComplete.push(callback);\r\n  }\r\n}\r\n\r\nexport default Runtime;\r\n","import { Pulse, Dep } from './internal';\r\nimport { copy, shallowmerge } from './utils';\r\nimport { deepmerge } from './helpers/deepmerge';\r\n\r\nexport class State<ValueType = any> {\r\n  // a unique key for this State\r\n  public name?: string;\r\n  // internal storage for the current value\r\n  public _value: ValueType = null;\r\n  // getter for the current value\r\n  public get value(): ValueType {\r\n    if (this.instance().runtime.trackState) this.instance().runtime.foundState.add(this);\r\n    return this._value;\r\n  }\r\n  // dependency manager class\r\n  public dep: Dep;\r\n\r\n  // watchers\r\n  public watchers?: { [key: string]: any };\r\n  // the previous value of this State\r\n  public previousState: ValueType = null;\r\n  // a copy of the current value that will be used if no param is passed on State.set()\r\n  public nextState: ValueType = null;\r\n  // if the value has been changed from initial value\r\n  public isSet: boolean = false;\r\n  // should Pulse attempt to persist this State value\r\n  public persistState: boolean;\r\n  // if this State locked to a particular type\r\n  public typeOfVal?: string;\r\n  // for extended classes to perform actions upon state change\r\n  public sideEffects?: Function;\r\n  // for extended classes to store a derived value, such as Group\r\n  public output?: any;\r\n  // getter and setter for the State value, best for I/O binding\r\n  public set bind(value: ValueType) {\r\n    this.set(value);\r\n  }\r\n  public get bind(): ValueType {\r\n    return this._value;\r\n  }\r\n  // is value truthey or falsey\r\n  public get exists(): boolean {\r\n    return !!this.value;\r\n  }\r\n\r\n  constructor(public instance: () => Pulse, public initialState, deps: Array<Dep> = []) {\r\n    // initialize the dependency manager\r\n    this.dep = new Dep(deps);\r\n    // write the initial value to this State\r\n    this.privateWrite(initialState);\r\n  }\r\n\r\n  /**\r\n   * Directly set state to a new value, if nothing is passed in State.nextState will be used as the next value\r\n   * @param newState - The new value for this state\r\n   */\r\n  public set(newState?: ValueType | SetFunc<ValueType>, options: { background?: boolean } = {}): this {\r\n    // if newState not provided, just ingest update with existing value\r\n    if (newState === undefined) {\r\n      this.instance().runtime.ingest(this, undefined);\r\n      return this;\r\n    }\r\n    // if newState is a function, run that function and supply existing value as first param\r\n    if (typeof newState === 'function') newState = (newState as SetFunc<ValueType>)(this._value);\r\n\r\n    // check type if set and correct otherwise exit\r\n    if (this.typeOfVal && !this.isCorrectType(newState)) {\r\n      console.warn(`Pulse: Error setting state: Incorrect type (${typeof newState}) was provided. Type fixed to ${this.typeOfVal}`);\r\n      return this;\r\n    }\r\n\r\n    // ingest update using most basic mutation method\r\n    if (options.background) {\r\n      this.privateWrite(newState);\r\n      if (this.sideEffects) this.sideEffects();\r\n    } else {\r\n      this.instance().runtime.ingest(this, newState);\r\n    }\r\n\r\n    this.isSet = true;\r\n    return this;\r\n  }\r\n\r\n  public getPublicValue(): ValueType {\r\n    if (this.output !== undefined) return this.output;\r\n    return this._value;\r\n  }\r\n\r\n  public patch(targetWithChange, config: { deep?: boolean } = {}): this {\r\n    if (!(typeof this._value === 'object')) return this;\r\n\r\n    this.nextState = config.deep === false ? shallowmerge(this.nextState, targetWithChange) : deepmerge(this.nextState, targetWithChange);\r\n\r\n    this.set();\r\n    return this;\r\n  }\r\n\r\n  public interval(setFunc: (currentValue: any) => any, ms?: number): this {\r\n    setInterval(() => {\r\n      this.set(setFunc(this.value));\r\n    }, ms || 1000);\r\n    return this;\r\n  }\r\n\r\n  public persist(key?: string): this {\r\n    this.persistState = true;\r\n    this.instance().storage.handleStatePersist(this, key);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @public\r\n   * Create a watcher that will fire a callback then destroy itself after invoking\r\n   */\r\n  public onNext(callback: (value: ValueType) => void) {\r\n    if (!this.watchers) this.watchers = {};\r\n    this.watchers['_on_next_'] = () => {\r\n      callback(this.getPublicValue());\r\n      delete this.watchers['_on_next_'];\r\n    };\r\n  }\r\n\r\n  /**\r\n   * @public\r\n   * Set a name for this State, required to persist\r\n   */\r\n  public key(key: string): this {\r\n    // if persist was attempted before, but no key was provided retry persist function\r\n    if (!this.name && this.persistState) this.persist(key);\r\n    this.name = key;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @public\r\n   * Fix the type to one of 'String', 'Boolean', 'Array', 'Object' or 'Number'\r\n   */\r\n  public type(type: TypeString | TypeConstructor): this {\r\n    const supportedConstructors = ['String', 'Boolean', 'Array', 'Object', 'Number'];\r\n    if (typeof type === 'function' && supportedConstructors.includes(type.name)) this.typeOfVal = type.name.toLowerCase();\r\n    else if (typeof type === 'string' && supportedConstructors.map(i => i.toLowerCase()).includes(type)) this.typeOfVal = type.toLowerCase();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @public\r\n   * Watch state for changes, run callback on each change\r\n   */\r\n  public watch(key: number | string, callback: (value: any) => void): this {\r\n    if (!this.watchers) this.watchers = {};\r\n\r\n    if (typeof key !== 'string' || typeof key !== 'number' || typeof callback !== 'function') {\r\n      // console.error('Pulse watch, missing key or function');\r\n    }\r\n    this.watchers[key] = callback;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @public\r\n   * Remove watcher by key\r\n   */\r\n  public removeWatcher(key: number | string): this {\r\n    delete this.watchers[key];\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @public\r\n   * Restore previous state\r\n   */\r\n  public undo() {\r\n    this.set(this.previousState);\r\n  }\r\n\r\n  /**\r\n   * @public\r\n   * If State is boolean, invert\r\n   */\r\n  public toggle(): this {\r\n    if (typeof this._value === 'boolean') {\r\n      // @ts-ignore\r\n      this.set(!this._value);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @public\r\n   * Reset the State to as declared\r\n   */\r\n  public reset(): this {\r\n    this.isSet = false;\r\n    this.previousState = null;\r\n    this.privateWrite(this.initialState);\r\n    if (this.persistState) this.instance().storage.remove(this.name);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @public\r\n   * Returns a copy of the current value, objects and arrays will be cloned\r\n   */\r\n  public copy(): any {\r\n    return copy(this.value);\r\n  }\r\n  /**\r\n   * @public\r\n   * Is the value equal to parameter\r\n   */\r\n  public is(x: any) {\r\n    return this.value === x;\r\n  }\r\n\r\n  /**\r\n   * @public\r\n   * Is the value not equal to parameter\r\n   */\r\n  public isNot(x: any) {\r\n    return this.value !== x;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   * Write value directly to State\r\n   */\r\n  public privateWrite(value: any) {\r\n    this._value = copy(value);\r\n    this.nextState = copy(value);\r\n    // If\r\n    if (this.persistState) this.instance().storage.set(this.name, this.getPersistableValue());\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   *\r\n   */\r\n  private isCorrectType(value): boolean {\r\n    let type: string = typeof value;\r\n    if (type === 'object' && Array.isArray(value)) type = 'array';\r\n    return type === this.typeOfVal;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   *\r\n   */\r\n  public destroy(): void {\r\n    this.dep.deps.clear();\r\n    this.dep.subs.clear();\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   *\r\n   */\r\n  public getPersistableValue(): any {\r\n    return this.value;\r\n  }\r\n}\r\n\r\nexport type StateGroupDefault = {\r\n  [key: string]: State | any;\r\n};\r\n\r\nexport const StateGroup = (instance: () => Pulse, stateGroup: Object): any => {\r\n  let group: any = {};\r\n  for (let name in stateGroup) {\r\n    group[name] = new State(instance, stateGroup[name]);\r\n    group[name].name = name;\r\n  }\r\n  return group;\r\n};\r\n\r\nexport default State;\r\n\r\nexport type SetFunc<ValueType> = (state: ValueType) => ValueType;\r\ntype TypeString = 'string' | 'boolean' | 'array' | 'object' | 'number';\r\ntype TypeConstructor = StringConstructor | BooleanConstructor | ArrayConstructor | ObjectConstructor | NumberConstructor;\r\n","import { Pulse, State } from './internal';\r\nimport { copy } from './utils';\r\n\r\ninterface StatusObjectData {\r\n  message: string | null;\r\n  status: 'invalid' | 'success' | 'error' | null;\r\n}\r\n\r\nconst initialData: StatusObjectData = {\r\n  message: null,\r\n  status: null\r\n};\r\n\r\nexport class StatusTracker {\r\n  public state: State<{ [key: string]: StatusObjectData }> = this.instance().State({});\r\n\r\n  public get all(): { [key: string]: StatusObjectData } {\r\n    return this.state.value;\r\n  }\r\n\r\n  constructor(private instance: () => Pulse) {}\r\n\r\n  public get(key: string): StatusObjectData {\r\n    return this?.state?.value[key];\r\n  }\r\n\r\n  public set(key: string): StatusObject {\r\n    if (!this.state.value[key]) {\r\n      this.state.set(Object.assign(copy(this.state.value), { [key]: initialData }));\r\n    }\r\n\r\n    return new StatusObject(this.state, key);\r\n  }\r\n\r\n  public remove(key: string): void {\r\n    if (!this.state.value[key]) return;\r\n\r\n    const copiedState: { [key: string]: StatusObjectData } = copy(this.state.value);\r\n\r\n    copiedState[key] = undefined;\r\n    delete copiedState[key];\r\n\r\n    this.state.set(copiedState);\r\n  }\r\n\r\n  public clear(key?: string): void {\r\n    // clearing a specific value\r\n    if (key) {\r\n      if (!this.state.value[key]) return;\r\n\r\n      const copiedState: { [key: string]: StatusObjectData } = copy(this.state.value);\r\n\r\n      copiedState[key] = initialData;\r\n\r\n      this.state.set(copiedState);\r\n\r\n      return;\r\n    }\r\n\r\n    this.state.reset();\r\n  }\r\n}\r\n\r\nexport class StatusObject {\r\n  constructor(private state: State<{ [key: string]: StatusObjectData }>, private key: string) {}\r\n\r\n  public status(newStatus: 'invalid' | 'success' | 'error' | 'none'): StatusObject {\r\n    this.state.set(Object.assign(copy(this.state.value), { [this.key]: { status: newStatus === 'none' ? null : newStatus } }));\r\n    return this;\r\n  }\r\n  public message(messageText: string): StatusObject {\r\n    this.state.set(Object.assign(copy(this.state.value), { [this.key]: { message: messageText } }));\r\n    return this;\r\n  }\r\n}\r\n\r\nexport default StatusTracker;\r\n","import { Pulse, State } from './internal';\r\nimport { defineConfig, isAsync } from './utils';\r\n\r\nexport interface StorageConfig {\r\n  type?: 'custom' | 'localStorage';\r\n  prefix?: string;\r\n  async?: boolean;\r\n  get?: any;\r\n  set?: any;\r\n  remove?: any;\r\n}\r\n\r\nexport class Storage {\r\n  public config: StorageConfig;\r\n  private storageReady: boolean = false;\r\n  public persistedState: Set<State> = new Set();\r\n\r\n  constructor(private instance: () => Pulse, config: StorageConfig) {\r\n    this.config = defineConfig(config, {\r\n      prefix: 'pulse',\r\n      type: 'localStorage'\r\n    });\r\n    // assume if user provided get, set or remove methods that the storage type is custom\r\n    if (this.config.get || this.config.set || this.config.remove) this.config.type = 'custom';\r\n\r\n    const ls = this.getLocalStorage();\r\n    if (this.config.type === 'localStorage' && ls) {\r\n      // assign localStorage crud functions to config object\r\n      ['get', 'set', 'remove'].forEach(type => (this.config[type] = ls[`${type}Item`].bind(ls)));\r\n      this.storageReady = true;\r\n    } else {\r\n      // Local storage not available, fallback to custom.\r\n      this.config.type = 'custom';\r\n      // ensuring all required storage properties are set\r\n      if (isFunction(this.config.get) && isFunction(this.config.set) && isFunction(this.config.remove)) {\r\n        // if asynchronous and developer did not explicitly define so, check\r\n        if (this.config.async === undefined && isAsync(this.config.get)) this.config.async = true;\r\n        this.storageReady = true;\r\n      } else {\r\n        // console.warn('Pulse Error: Persistent storage not configured, check get, set and remove methods', this.config);\r\n        this.storageReady = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  public get(key: string) {\r\n    if (!this.storageReady) return;\r\n    if (this.config.async) {\r\n      return new Promise((resolve, reject) => {\r\n        this.config\r\n          .get(this.getKey(key))\r\n          .then(res => {\r\n            // if result is not JSON for some reason, return it.\r\n            if (typeof res !== 'string') return resolve(res);\r\n            resolve(JSON.parse(res));\r\n          })\r\n          .catch(reject);\r\n      });\r\n    } else {\r\n      try {\r\n        return JSON.parse(this.config.get(this.getKey(key)));\r\n      } catch (e) {\r\n        return undefined;\r\n      }\r\n    }\r\n  }\r\n\r\n  public set(key: string, value: any) {\r\n    if (!this.storageReady) return;\r\n    this.config.set(this.getKey(key), JSON.stringify(value));\r\n  }\r\n\r\n  public remove(key: string) {\r\n    if (!this.storageReady) return;\r\n    this.config.remove(this.getKey(key));\r\n  }\r\n\r\n  private getKey(key: string) {\r\n    return `_${this.config.prefix}_${key}`;\r\n  }\r\n  // used by State and Selector to persist value inside storage\r\n\r\n  public handleStatePersist(state: State, key: string) {\r\n    const storage = this;\r\n    // validation\r\n    if (!key && state.name) {\r\n      key = state.name;\r\n    } else if (!key) {\r\n      return;\r\n      // console.warn('Pulse Persist Error: No key provided');\r\n    } else {\r\n      state.name = key;\r\n    }\r\n    // add ref to state instance inside storage\r\n    storage.persistedState.add(state);\r\n\r\n    // handle the value\r\n    const handle = (storageVal: any) => {\r\n      // if no storage value found, set current value in storage\r\n      if (storageVal === null) storage.set(state.name, state.getPersistableValue());\r\n      // if Selector, select current storage value\r\n      else if (typeof state['select'] === 'function' && (typeof storageVal === 'string' || typeof storageVal === 'number'))\r\n        state['select'](storageVal);\r\n      // otherwise just ingest the storage value so that the State updates\r\n      else state.instance().runtime.ingest(state, storageVal);\r\n    };\r\n    // Check if promise, then handle value\r\n    if (storage.config.async) storage.get(state.name).then((value: any) => handle(value));\r\n    // non promise\r\n    else handle(storage.get(state.name));\r\n  }\r\n\r\n  private getLocalStorage() {\r\n    try {\r\n      const ls = window?.localStorage ? window.localStorage : localStorage;\r\n      if (typeof ls.getItem !== 'function') return false;\r\n      return ls;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\nfunction isFunction(func: () => any) {\r\n  return typeof func === 'function';\r\n}\r\n\r\nexport default Storage;\r\n\r\n// Handy utils\r\nexport function persist(items: Array<State>): void {\r\n  items.forEach(item => item.persist(item.name));\r\n}\r\n","// Global Subscription Controller\r\n// This class handles external components subscribing to Pulse.\r\nimport { Pulse, State } from './internal';\r\nimport Collection from './collection/collection';\r\n\r\nexport type SubscriptionContainer = ComponentContainer | CallbackContainer;\r\n\r\nexport class ComponentContainer {\r\n  public component: any;\r\n\r\n  // Only needed object orientated subscriptions\r\n  public passProps: boolean = false;\r\n  public propStates?: { [key: string]: State }; // States which will than be returned as prop object by the integration\r\n  public propKeysChanged: Array<string> = []; // needed to build updatedData for the integration updateMethod.. it temporary saves changed state keys to build later with it the prop object\r\n\r\n  public ready: boolean = false;\r\n  public subs: Set<State> = new Set<State>([]); // States that are subscribed by this component\r\n\r\n  constructor(component: any, subs?: Set<State>) {\r\n    this.component = component;\r\n    if (subs) this.subs = subs;\r\n  }\r\n}\r\n\r\nexport class CallbackContainer extends ComponentContainer {\r\n  public callback: Function;\r\n\r\n  constructor(callback: Function, subs?: Set<State>) {\r\n    super(null, subs);\r\n    this.callback = callback;\r\n  }\r\n}\r\n\r\nexport class SubController {\r\n  public pulseInstance;\r\n\r\n  // Component based Subscription\r\n  public components: Set<ComponentContainer> = new Set();\r\n\r\n  // Callback based Subscription\r\n  public callbacks: Set<CallbackContainer> = new Set();\r\n\r\n  constructor(pulseInstance: Pulse) {\r\n    this.pulseInstance = pulseInstance;\r\n  }\r\n\r\n  /**\r\n   * Subscribe to Pulse State with a returned object of props this props can than be returned by the component (See react-integration)\r\n   */\r\n  public subscribeWithSubsObject(\r\n    subscriptionInstance: any,\r\n    subs: { [key: string]: State } = {}\r\n  ): { subscriptionContainer: SubscriptionContainer; props: { [key: string]: State['value'] } } {\r\n    const subscriptionContainer = this.registerSubscription(subscriptionInstance);\r\n\r\n    const props: { [key: string]: State } = {};\r\n    subscriptionContainer.passProps = true;\r\n    subscriptionContainer.propStates = { ...subs };\r\n\r\n    // Go through subs\r\n    let localKeys = Object.keys(subs);\r\n    localKeys.forEach(key => {\r\n      const state = subs[key];\r\n\r\n      // Add State to SubscriptionContainer Subs\r\n      subscriptionContainer.subs.add(state);\r\n\r\n      // Add SubscriptionContainer to State Subs\r\n      state.dep.subs.add(subscriptionContainer);\r\n\r\n      // Add state to props\r\n      props[key] = state.value;\r\n    });\r\n\r\n    return {\r\n      subscriptionContainer: subscriptionContainer,\r\n      props: props\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Subscribe to Pulse State\r\n   */\r\n  public subscribeWithSubsArray(subscriptionInstance: any, subs: Array<State> = []): SubscriptionContainer {\r\n    const subscriptionContainer = this.registerSubscription(subscriptionInstance, subs);\r\n\r\n    subs.forEach(state => {\r\n      // Add State to SubscriptionContainer Subs\r\n      if (state instanceof Collection) {\r\n        const collection = state as Collection;\r\n        if (collection.groups?.default) state = collection.getGroup('default');\r\n        else throw 'usePulse error, Collection has no default group';\r\n      }\r\n\r\n      subscriptionContainer.subs.add(state);\r\n\r\n      // Add SubscriptionContainer to State Subs\r\n      state.dep.subs.add(subscriptionContainer);\r\n    });\r\n\r\n    return subscriptionContainer;\r\n  }\r\n\r\n  /**\r\n   * Registers the Component/Callback Subscription and returns a SubscriptionContainer\r\n   */\r\n  public registerSubscription(integrationInstance: any, subs: Array<State> = []): SubscriptionContainer {\r\n    // - Callback based Subscription\r\n    if (typeof integrationInstance === 'function') {\r\n      const callbackContainer = new CallbackContainer(integrationInstance as Function, new Set(subs));\r\n      this.callbacks.add(callbackContainer);\r\n      callbackContainer.ready = true;\r\n\r\n      return callbackContainer;\r\n    }\r\n\r\n    // - Component based Subscription\r\n    const componentContainer = new ComponentContainer(integrationInstance);\r\n\r\n    // Instantiate the componentContainer in a Component (for instance see react.integration PulseHOC)\r\n    integrationInstance.componentContainer = componentContainer;\r\n\r\n    this.components.add(componentContainer);\r\n    if (!this.pulseInstance.config.waitForMount) componentContainer.ready = true;\r\n\r\n    return componentContainer;\r\n  }\r\n\r\n  /**\r\n   * This will mount the component (Mounts currently only useful in Component based Subscription)\r\n   */\r\n  public mount(integrationInstance: any) {\r\n    if (integrationInstance.componentContainer) integrationInstance.componentContainer.ready = true;\r\n  }\r\n\r\n  /**\r\n   * Unsubscribe a component or callback\r\n   */\r\n  public unsubscribe(subscriptionInstance: any) {\r\n    const unsub = (subscriptionContainer: CallbackContainer | ComponentContainer) => {\r\n      subscriptionContainer.ready = false;\r\n\r\n      // Removes SubscriptionContainer from State subs\r\n      subscriptionContainer.subs.forEach(state => {\r\n        state.dep.subs.delete(subscriptionInstance);\r\n      });\r\n    };\r\n\r\n    if (subscriptionInstance instanceof CallbackContainer) unsub(subscriptionInstance);\r\n    else if (subscriptionInstance.componentContainer) unsub(subscriptionInstance.componentContainer);\r\n  }\r\n}\r\n\r\nexport default SubController;\r\n","import { Pulse, State, Collection } from './internal';\r\nimport { extractAll } from './helpers/extractAll';\r\nimport { isWatchableObject } from './helpers/isWatchableObj';\r\n\r\nexport function cleanState<T>(state: State<T>): object {\r\n  return {\r\n    value: state.value,\r\n    previousState: state.previousState,\r\n    isSet: state.isSet,\r\n    dependents: state.dep.deps.size,\r\n    subscribers: state.dep.subs.size,\r\n    name: state.name\r\n  };\r\n}\r\n\r\nexport function resetState(items: Iterable<State | Collection | any>) {\r\n  for (const item of items) {\r\n    if (item instanceof Collection) item.reset();\r\n    if (item instanceof State) return item.reset();\r\n    const stateSet = extractAll(State, item);\r\n    stateSet.forEach(state => state.reset());\r\n  }\r\n}\r\n\r\nexport function getPulseInstance(state: State): Pulse {\r\n  try {\r\n    if (state.instance) return state.instance();\r\n    else return globalThis.__pulse;\r\n  } catch (e) {}\r\n}\r\n\r\nexport function normalizeDeps(deps: Array<State> | State) {\r\n  return Array.isArray(deps) ? (deps as Array<State>) : [deps as State];\r\n}\r\n\r\nexport const copy = val => {\r\n  // ignore if primitive type\r\n  if (typeof val !== 'object') return val;\r\n\r\n  if (isWatchableObject(val)) val = { ...val };\r\n  else if (Array.isArray(val)) val = [...val];\r\n\r\n  return val;\r\n};\r\n\r\n// groups are defined by the user as an array of strings, this converts them into object/keys\r\nexport function normalizeGroups(groupsAsArray: any = []) {\r\n  const groups: object = {};\r\n  for (let i = 0; i < groupsAsArray.length; i++) {\r\n    const groupName = groupsAsArray[i];\r\n    groups[groupName] = [];\r\n  }\r\n  return groups;\r\n}\r\n\r\nexport function shallowmerge(source, changes) {\r\n  let keys = Object.keys(changes);\r\n  keys.forEach(property => {\r\n    source[property] = changes[property];\r\n  });\r\n\r\n  return source;\r\n}\r\n\r\nexport function defineConfig<C>(config: C, defaults): C {\r\n  return { ...defaults, ...config };\r\n}\r\n\r\nexport function genId(): string {\r\n  return Math.random().toString().split('.')[1] + Date.now();\r\n}\r\n\r\nexport function isFunction(func: () => any) {\r\n  return typeof func === 'function';\r\n}\r\n\r\nexport function isAsync(func: () => any) {\r\n  return func.constructor.name === 'AsyncFunction';\r\n}\r\n\r\nexport function normalizeMap(map) {\r\n  return Array.isArray(map) ? map.map(key => ({ key, val: key })) : Object.keys(map).map(key => ({ key, val: map[key] }));\r\n}\r\n\r\nexport function cleanse(object: any) {\r\n  if (!isWatchableObject(object)) return object;\r\n  const clean = Object.assign({}, object);\r\n  const properties = Object.keys(clean);\r\n\r\n  for (let i = 0; i < properties.length; i++) {\r\n    const property = properties[i];\r\n\r\n    if (isWatchableObject(clean[property])) {\r\n      clean[property] = cleanse(clean[property]);\r\n    }\r\n  }\r\n  return clean;\r\n}\r\n\r\nexport function validateNumber(mutable, amount) {\r\n  if (typeof amount !== 'number' || typeof mutable !== 'number') {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\nexport function normalizeArray(items: any | Array<any>): Array<any> {\r\n  return Array.isArray(items) ? items : [items];\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// run startup\nreturn __webpack_require__.x();\n","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// Promise = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"index\": 0\n};\n\nvar deferredModules = [\n\t[\"./lib/index.ts\"]\n];\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\nvar checkDeferredModules = () => {\n\n};\nfunction checkDeferredModulesImpl() {\n\tvar result;\n\tfor(var i = 0; i < deferredModules.length; i++) {\n\t\tvar deferredModule = deferredModules[i];\n\t\tvar fulfilled = true;\n\t\tfor(var j = 1; j < deferredModule.length; j++) {\n\t\t\tvar depId = deferredModule[j];\n\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferredModules.splice(i--, 1);\n\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n\t\t}\n\t}\n\tif(deferredModules.length === 0) {\n\t\t__webpack_require__.x();\n\t\t__webpack_require__.x = () => {\n\n\t\t}\n\t}\n\treturn result;\n}\n__webpack_require__.x = () => {\n\t// reset startup function so it can be called again when more startup code is added\n\t__webpack_require__.x = () => {\n\n\t}\n\tchunkLoadingGlobal = chunkLoadingGlobal.slice();\n\tfor(var i = 0; i < chunkLoadingGlobal.length; i++) webpackJsonpCallback(chunkLoadingGlobal[i]);\n\treturn (checkDeferredModules = checkDeferredModulesImpl)();\n};\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (data) => {\n\tvar [chunkIds, moreModules, runtime, executeModules] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0, resolves = [];\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tresolves.push(installedChunks[chunkId][0]);\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\tfor(moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\tparentChunkLoadingFunction(data);\n\twhile(resolves.length) {\n\t\tresolves.shift()();\n\t}\n\n\t// add entry modules from loaded chunk to deferred list\n\tif(executeModules) deferredModules.push.apply(deferredModules, executeModules);\n\n\t// run deferred modules when all chunks ready\n\treturn checkDeferredModules();\n}\n\nvar chunkLoadingGlobal = globalThis[\"webpackChunkpulse_framework\"] = globalThis[\"webpackChunkpulse_framework\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = webpackJsonpCallback;"],"sourceRoot":""}